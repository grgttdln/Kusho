<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/components/LearnerProfileAnnotationDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/components/LearnerProfileAnnotationDialog.kt" />
              <option name="updatedContent" value="package com.example.app.ui.components&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.app.R&#10;&#10;private val PurpleColor = Color(0xFFAE8EFB)&#10;&#10;/**&#10; * Data class representing a selectable chip option&#10; */&#10;data class ChipOption(&#10;    val label: String,&#10;    val color: Color,&#10;    val isSelected: Boolean = false&#10;)&#10;&#10;/**&#10; * Selectable chip with colored dot indicator&#10; */&#10;@Composable&#10;fun SelectableChip(&#10;    label: String,&#10;    dotColor: Color,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    val borderColor = if (isSelected) PurpleColor else Color(0xFFE0E0E0)&#10;    val backgroundColor = if (isSelected) PurpleColor.copy(alpha = 0.1f) else Color.White&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(20.dp),&#10;        colors = CardDefaults.cardColors(containerColor = backgroundColor),&#10;        border = BorderStroke(1.dp, borderColor)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;        ) {&#10;            // Colored dot&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(8.dp)&#10;                    .clip(RoundedCornerShape(50))&#10;                    .background(dotColor)&#10;            )&#10;            Text(&#10;                text = label,&#10;                fontSize = 13.sp,&#10;                color = Color.Black&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Learner Profile Annotation Dialog&#10; * Shows when the annotate button is clicked to allow teachers to record observations&#10; * Features scrollable content and smooth slide-up/down animation&#10; */&#10;@Composable&#10;fun LearnerProfileAnnotationDialog(&#10;    studentName: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onAddNote: (&#10;        levelOfProgress: String?,&#10;        strengthsObserved: List&lt;String&gt;,&#10;        strengthsNote: String,&#10;        challenges: List&lt;String&gt;,&#10;        challengesNote: String&#10;    ) -&gt; Unit&#10;) {&#10;    // Animation state for slide-up/down effect&#10;    var isVisible by remember { mutableStateOf(false) }&#10;    var isClosing by remember { mutableStateOf(false) }&#10;    &#10;    val slideOffset by androidx.compose.animation.core.animateFloatAsState(&#10;        targetValue = if (isVisible &amp;&amp; !isClosing) 0f else 1f,&#10;        animationSpec = androidx.compose.animation.core.tween(&#10;            durationMillis = 300,&#10;            easing = if (isClosing) &#10;                androidx.compose.animation.core.FastOutLinearInEasing &#10;            else &#10;                androidx.compose.animation.core.FastOutSlowInEasing&#10;        ),&#10;        finishedListener = { &#10;            if (isClosing) {&#10;                onDismiss()&#10;            }&#10;        },&#10;        label = &quot;slideOffset&quot;&#10;    )&#10;    val backgroundAlpha by androidx.compose.animation.core.animateFloatAsState(&#10;        targetValue = if (isVisible &amp;&amp; !isClosing) 0.5f else 0f,&#10;        animationSpec = androidx.compose.animation.core.tween(&#10;            durationMillis = 300&#10;        ),&#10;        label = &quot;backgroundAlpha&quot;&#10;    )&#10;&#10;    // Function to trigger close animation&#10;    val animateClose: () -&gt; Unit = {&#10;        isClosing = true&#10;    }&#10;&#10;    // Trigger animation when dialog appears&#10;    LaunchedEffect(Unit) {&#10;        isVisible = true&#10;    }&#10;&#10;    // Level of Progress options&#10;    val levelOptions = listOf(&#10;        ChipOption(&quot;Beginning&quot;, Color(0xFFFF6B6B)),&#10;        ChipOption(&quot;Developing&quot;, Color(0xFFFFB800)),&#10;        ChipOption(&quot;Proficient&quot;, Color(0xFF4CAF50)),&#10;        ChipOption(&quot;Advanced&quot;, Color(0xFF2196F3))&#10;    )&#10;    var selectedLevel by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Strengths Observed options&#10;    val strengthOptions = listOf(&quot;Recognition&quot;, &quot;Fluency&quot;, &quot;Formation&quot;)&#10;    var selectedStrengths by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }&#10;    var strengthsNote by remember { mutableStateOf(&quot;&quot;) }&#10;    var showStrengthsNoteField by remember { mutableStateOf(false) }&#10;&#10;    // Challenges options&#10;    val challengeOptions = listOf(&quot;Recognition&quot;, &quot;Fluency&quot;, &quot;Formation&quot;)&#10;    var selectedChallenges by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }&#10;    var challengesNote by remember { mutableStateOf(&quot;&quot;) }&#10;    var showChallengesNoteField by remember { mutableStateOf(false) }&#10;&#10;    // Scroll state for content&#10;    val scrollState = androidx.compose.foundation.rememberScrollState()&#10;&#10;    Dialog(&#10;        onDismissRequest = animateClose,&#10;        properties = DialogProperties(usePlatformDefaultWidth = false)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black.copy(alpha = backgroundAlpha))&#10;                .clickable(&#10;                    indication = null,&#10;                    interactionSource = remember { MutableInteractionSource() }&#10;                ) { animateClose() },&#10;            contentAlignment = Alignment.BottomCenter&#10;        ) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .fillMaxHeight(0.75f)&#10;                    .offset(y = (slideOffset * 600).dp)&#10;                    .clickable(&#10;                        indication = null,&#10;                        interactionSource = remember { MutableInteractionSource() }&#10;                    ) { /* Prevent click through */ },&#10;                shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.White)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                ) {&#10;                    // Fixed Header with icon and student name&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(start = 24.dp, end = 24.dp, top = 24.dp, bottom = 16.dp)&#10;                    ) {&#10;                        // Drag handle indicator&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .align(Alignment.CenterHorizontally)&#10;                                .width(40.dp)&#10;                                .height(4.dp)&#10;                                .clip(RoundedCornerShape(2.dp))&#10;                                .background(Color.LightGray)&#10;                        )&#10;                        &#10;                        Spacer(Modifier.height(16.dp))&#10;                        &#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            Image(&#10;                                painter = painterResource(id = R.drawable.ic_annotate),&#10;                                contentDescription = &quot;Profile&quot;,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                            Spacer(Modifier.width(12.dp))&#10;                            Text(&#10;                                text = &quot;Learner Profile: $studentName&quot;,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = Color.Black&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Scrollable content&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(scrollState)&#10;                            .padding(horizontal = 24.dp)&#10;                    ) {&#10;                        // Level of Progress section&#10;                        Text(&#10;                            text = &quot;Level of Progress&quot;,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        // Level chips - first row&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            levelOptions.take(3).forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option.label,&#10;                                    dotColor = option.color,&#10;                                    isSelected = selectedLevel == option.label,&#10;                                    onClick = {&#10;                                        selectedLevel = if (selectedLevel == option.label) null else option.label&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                        Spacer(Modifier.height(8.dp))&#10;                        // Level chips - second row&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            levelOptions.drop(3).forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option.label,&#10;                                    dotColor = option.color,&#10;                                    isSelected = selectedLevel == option.label,&#10;                                    onClick = {&#10;                                        selectedLevel = if (selectedLevel == option.label) null else option.label&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(24.dp))&#10;&#10;                        // Strengths Observed section&#10;                        Text(&#10;                            text = &quot;Strengths Observed&quot;,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            strengthOptions.forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option,&#10;                                    dotColor = Color(0xFF2196F3),&#10;                                    isSelected = option in selectedStrengths,&#10;                                    onClick = {&#10;                                        selectedStrengths = if (option in selectedStrengths) {&#10;                                            selectedStrengths - option&#10;                                        } else {&#10;                                            selectedStrengths + option&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(8.dp))&#10;&#10;                        // Add Note for Strengths&#10;                        if (showStrengthsNoteField) {&#10;                            androidx.compose.material3.OutlinedTextField(&#10;                                value = strengthsNote,&#10;                                onValueChange = { strengthsNote = it },&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                placeholder = { Text(&quot;Add a note...&quot;, color = Color.Gray) },&#10;                                colors = androidx.compose.material3.OutlinedTextFieldDefaults.colors(&#10;                                    focusedBorderColor = PurpleColor,&#10;                                    unfocusedBorderColor = Color.LightGray&#10;                                ),&#10;                                minLines = 2,&#10;                                maxLines = 4&#10;                            )&#10;                        } else {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .clickable { showStrengthsNoteField = true }&#10;                                    .padding(vertical = 8.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;+ Add Note&quot;,&#10;                                    fontSize = 14.sp,&#10;                                    color = PurpleColor&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(24.dp))&#10;&#10;                        // Challenges section&#10;                        Text(&#10;                            text = &quot;Challenges&quot;,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            challengeOptions.forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option,&#10;                                    dotColor = Color(0xFF2196F3),&#10;                                    isSelected = option in selectedChallenges,&#10;                                    onClick = {&#10;                                        selectedChallenges = if (option in selectedChallenges) {&#10;                                            selectedChallenges - option&#10;                                        } else {&#10;                                            selectedChallenges + option&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(8.dp))&#10;&#10;                        // Add Note for Challenges&#10;                        if (showChallengesNoteField) {&#10;                            androidx.compose.material3.OutlinedTextField(&#10;                                value = challengesNote,&#10;                                onValueChange = { challengesNote = it },&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                placeholder = { Text(&quot;Add a note...&quot;, color = Color.Gray) },&#10;                                colors = androidx.compose.material3.OutlinedTextFieldDefaults.colors(&#10;                                    focusedBorderColor = PurpleColor,&#10;                                    unfocusedBorderColor = Color.LightGray&#10;                                ),&#10;                                minLines = 2,&#10;                                maxLines = 4&#10;                            )&#10;                        } else {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .clickable { showChallengesNoteField = true }&#10;                                    .padding(vertical = 8.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;+ Add Note&quot;,&#10;                                    fontSize = 14.sp,&#10;                                    color = PurpleColor&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        // Bottom padding for scroll content&#10;                        Spacer(Modifier.height(24.dp))&#10;                    }&#10;&#10;                    // Fixed Add Note button at bottom&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .background(Color.White)&#10;                            .padding(24.dp)&#10;                    ) {&#10;                        androidx.compose.material3.Button(&#10;                            onClick = {&#10;                                onAddNote(&#10;                                    selectedLevel,&#10;                                    selectedStrengths.toList(),&#10;                                    strengthsNote,&#10;                                    selectedChallenges.toList(),&#10;                                    challengesNote&#10;                                )&#10;                                animateClose()&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(56.dp),&#10;                            shape = RoundedCornerShape(16.dp),&#10;                            colors = androidx.compose.material3.ButtonDefaults.buttonColors(&#10;                                containerColor = Color(0xFF4A90D9)&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Add Note&quot;,&#10;                                fontSize = 16.sp,&#10;                                fontWeight = FontWeight.SemiBold,&#10;                                color = Color.White&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/learnmode/LearnModeSessionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/learnmode/LearnModeSessionScreen.kt" />
              <option name="originalContent" value="package com.example.app.ui.feature.learn.learnmode&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import coil.compose.rememberAsyncImagePainter&#10;import coil.request.ImageRequest&#10;import com.example.app.R&#10;import com.example.app.data.AppDatabase&#10;import com.example.app.data.repository.SetRepository&#10;import com.example.app.service.WatchConnectionManager&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;private val PurpleColor = Color(0xFFAE8EFB)&#10;private val LightPurpleColor = Color(0xFFE7DDFE)&#10;private val CompletedLetterColor = Color(0xFFAE8EFB)&#10;private val PendingLetterColor = Color(0xFF808080)&#10;&#10;/**&#10; * Letters that have very similar writing structures between uppercase and lowercase&#10; * in air writing. These letters should be checked case-insensitively.&#10; */&#10;private val similarCaseLetters = setOf('c', 'k', 'o', 'p', 's', 'u', 'v', 'w', 'x', 'z',&#10;                                       'C', 'K', 'O', 'P', 'S', 'U', 'V', 'W', 'X', 'Z')&#10;&#10;/**&#10; * Check if the input letter matches the expected letter.&#10; * For letters with similar writing structures (c, k, o, p, s, u, v, w, x, z),&#10; * the comparison is case-insensitive.&#10; * For other letters, the comparison is case-sensitive.&#10; */&#10;private fun isLetterMatch(inputLetter: Char?, expectedLetter: Char?): Boolean {&#10;    if (inputLetter == null || expectedLetter == null) return false&#10;&#10;    // If the expected letter is one with similar case writing structure, compare case-insensitively&#10;    return if (expectedLetter in similarCaseLetters) {&#10;        inputLetter.lowercaseChar() == expectedLetter.lowercaseChar()&#10;    } else {&#10;        inputLetter == expectedLetter&#10;    }&#10;}&#10;&#10;/**&#10; * Data class representing a word item in the learn mode session.&#10; */&#10;private data class WordItem(&#10;    val word: String,&#10;    val selectedLetterIndex: Int,&#10;    val imagePath: String?,&#10;    val configurationType: String&#10;) {&#10;    fun getMaskedWord(): String {&#10;        return word.mapIndexed { index, char -&gt;&#10;            if (index == selectedLetterIndex) &quot;_&quot; else char&#10;        }.joinToString(&quot; &quot;)&#10;    }&#10;&#10;    fun getFullWord(): String {&#10;        return word.toList().joinToString(&quot; &quot;)&#10;    }&#10;&#10;    fun getBlankWord(): String {&#10;        return word.map { &quot;â–¬&quot; }.joinToString(&quot;  &quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LearnModeSessionScreen(&#10;    setId: Long = 0L,&#10;    activityTitle: String = &quot;&quot;,&#10;    sessionKey: Int = 0,&#10;    studentName: String = &quot;&quot;,&#10;    modifier: Modifier = Modifier,&#10;    onSkip: () -&gt; Unit = {},&#10;    onAudioClick: () -&gt; Unit = {},&#10;    onSessionComplete: () -&gt; Unit = {}&#10;) {&#10;    // Local state - fresh on each recomposition with new sessionKey&#10;    var isLoading by remember(sessionKey) { mutableStateOf(true) }&#10;    var words by remember(sessionKey) { mutableStateOf&lt;List&lt;WordItem&gt;&gt;(emptyList()) }&#10;    var currentWordIndex by remember(sessionKey) { mutableIntStateOf(0) }&#10;    var title by remember(sessionKey) { mutableStateOf(activityTitle) }&#10;&#10;    // State for Write the Word mode - tracks which letters have been correctly input&#10;    var completedLetterIndices by remember(sessionKey) { mutableStateOf&lt;Set&lt;Int&gt;&gt;(emptySet()) }&#10;    var currentLetterIndex by remember(sessionKey) { mutableIntStateOf(0) }&#10;&#10;    // State for Fill in the Blank mode - tracks if the masked letter has been correctly answered&#10;    var fillInBlankCorrect by remember(sessionKey) { mutableStateOf(false) }&#10;&#10;    // State for ProgressCheckDialog&#10;    var showProgressCheckDialog by remember(sessionKey) { mutableStateOf(false) }&#10;    var isCorrectGesture by remember(sessionKey) { mutableStateOf(false) }&#10;    var predictedLetter by remember(sessionKey) { mutableStateOf(&quot;&quot;) }&#10;    var targetLetter by remember(sessionKey) { mutableStateOf(&quot;&quot;) }&#10;    var targetCase by remember(sessionKey) { mutableStateOf(&quot;&quot;) }&#10;    &#10;    // Store pending state changes to apply after dialog dismissal&#10;    var pendingCorrectAction by remember(sessionKey) { mutableStateOf&lt;(() -&gt; Unit)?&gt;(null) }&#10;&#10;    // State for Learner Profile Annotation Dialog&#10;    var showAnnotationDialog by remember(sessionKey) { mutableStateOf(false) }&#10;&#10;    val context = LocalContext.current&#10;&#10;    // Get WatchConnectionManager instance&#10;    val watchConnectionManager = remember { WatchConnectionManager.getInstance(context) }&#10;    &#10;    // Notify watch when Learn Mode session starts&#10;    LaunchedEffect(sessionKey) {&#10;        watchConnectionManager.notifyLearnModeStarted()&#10;    }&#10;    &#10;    // Note: We don't call notifyLearnModeEnded() here on dispose anymore&#10;    // because we want the watch to keep showing the completion screen&#10;    // while the phone shows the analytics screen.&#10;    // notifyLearnModeEnded() is now called from LearnModeSessionAnalyticsScreen&#10;    // when the user leaves (Practice Again or Continue).&#10;&#10;    // Load data when screen opens - using sessionKey as key ensures this runs fresh each time&#10;    LaunchedEffect(setId, sessionKey) {&#10;        if (setId &gt; 0) {&#10;            isLoading = true&#10;            try {&#10;                val database = AppDatabase.getInstance(context)&#10;                val setRepository = SetRepository(&#10;                    database.setDao(),&#10;                    database.setWordDao(),&#10;                    database.wordDao()&#10;                )&#10;&#10;                val setDetails = withContext(Dispatchers.IO) {&#10;                    setRepository.getSetDetails(setId)&#10;                }&#10;&#10;                if (setDetails != null) {&#10;                    words = setDetails.words.map { wordConfig -&gt;&#10;                        WordItem(&#10;                            word = wordConfig.word,&#10;                            selectedLetterIndex = wordConfig.selectedLetterIndex,&#10;                            imagePath = wordConfig.imagePath,&#10;                            configurationType = wordConfig.configurationType&#10;                        )&#10;                    }&#10;                    title = activityTitle&#10;                }&#10;            } catch (e: Exception) {&#10;                // Handle error silently&#10;            } finally {&#10;                isLoading = false&#10;            }&#10;        } else {&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    // Send current word data to watch whenever current word changes&#10;    LaunchedEffect(currentWordIndex, words) {&#10;        val currentWord = words.getOrNull(currentWordIndex)&#10;        if (currentWord != null) {&#10;            // Reset letter tracking state for new word&#10;            completedLetterIndices = emptySet()&#10;            currentLetterIndex = 0&#10;            fillInBlankCorrect = false&#10;&#10;            watchConnectionManager.sendLearnModeWordData(&#10;                word = currentWord.word,&#10;                maskedIndex = currentWord.selectedLetterIndex,&#10;                configurationType = currentWord.configurationType&#10;            )&#10;        }&#10;    }&#10;&#10;    // Listen for letter input events from watch (for Write the Word, Name the Picture, and Fill in the Blank modes)&#10;    LaunchedEffect(Unit) {&#10;        var lastEventTime = 0L&#10;        watchConnectionManager.letterInputEvent.collect { event -&gt;&#10;            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Received letterInputEvent: letter=${event.letter}, timestamp=${event.timestamp}, lastEventTime=$lastEventTime&quot;)&#10;&#10;            // Process event only if timestamp is valid (&gt; 0) and newer than last processed event&#10;            if (event.timestamp &gt; 0L &amp;&amp; event.timestamp &gt; lastEventTime) {&#10;                lastEventTime = event.timestamp&#10;                val currentWord = words.getOrNull(currentWordIndex)&#10;                android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Processing event: currentWord=${currentWord?.word}, type=${currentWord?.configurationType}, currentWordIndex=$currentWordIndex&quot;)&#10;                if (currentWord != null) {&#10;                    when (currentWord.configurationType) {&#10;                        &quot;Fill in the Blank&quot; -&gt; {&#10;                            // For Fill in the Blank, check if the masked letter is correct&#10;                            val expectedLetter = currentWord.word.getOrNull(currentWord.selectedLetterIndex)&#10;                            // Use case-insensitive matching for similar letters (c, k, o, p, s, u, v, w, x, z)&#10;                            val isCorrect = isLetterMatch(event.letter, expectedLetter)&#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Fill in the Blank: input=${event.letter}, expected=$expectedLetter, isCorrect=$isCorrect&quot;)&#10;&#10;                            // Set up dialog state&#10;                            targetLetter = expectedLetter?.toString() ?: &quot;&quot;&#10;                            targetCase = if (expectedLetter?.isUpperCase() == true) &quot;capital&quot; else &quot;small&quot;&#10;                            predictedLetter = event.letter.toString()&#10;                            isCorrectGesture = isCorrect&#10;                            &#10;                            // Send feedback to watch so it shows the same screen&#10;                            watchConnectionManager.sendLearnModeFeedback(isCorrect, event.letter.toString())&#10;&#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Setting showProgressCheckDialog = true for Fill in the Blank&quot;)&#10;                            showProgressCheckDialog = true&#10;&#10;                            // Store pending action to execute on dialog dismiss&#10;                            if (isCorrect) {&#10;                                pendingCorrectAction = {&#10;                                    // Mark Fill in the Blank as correct to reveal the letter&#10;                                    fillInBlankCorrect = true&#10;                                    &#10;                                    // Correct answer - notify watch and move to next word&#10;                                    watchConnectionManager.sendWordComplete()&#10;                                    &#10;                                    if (currentWordIndex &lt; words.size - 1) {&#10;                                        currentWordIndex++&#10;                                    } else {&#10;                                        // All items complete - notify watch before navigating away&#10;                                        watchConnectionManager.notifyActivityComplete()&#10;                                        onSessionComplete()&#10;                                    }&#10;                                }&#10;                            } else {&#10;                                pendingCorrectAction = {&#10;                                    // Wrong letter - send incorrect feedback and resend word data for retry&#10;                                    watchConnectionManager.sendLetterResult(false, currentWord.selectedLetterIndex, currentWord.word.length)&#10;                                    // Resend word data so watch can prompt user to retry&#10;                                    watchConnectionManager.sendLearnModeWordData(&#10;                                        word = currentWord.word,&#10;                                        maskedIndex = currentWord.selectedLetterIndex,&#10;                                        configurationType = currentWord.configurationType&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                        &quot;Write the Word&quot;, &quot;Name the Picture&quot; -&gt; {&#10;                            // Get expected letter&#10;                            val expectedLetter = currentWord.word.getOrNull(currentLetterIndex)&#10;&#10;                            // Check if input letter matches expected letter&#10;                            // Uses case-insensitive matching for similar letters (c, k, o, p, s, u, v, w, x, z)&#10;                            val isCorrect = isLetterMatch(event.letter, expectedLetter)&#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Write the Word/Name the Picture: input=${event.letter}, expected=$expectedLetter, isCorrect=$isCorrect&quot;)&#10;&#10;                            // Set up dialog state&#10;                            targetLetter = expectedLetter?.toString() ?: &quot;&quot;&#10;                            targetCase = if (expectedLetter?.isUpperCase() == true) &quot;capital&quot; else &quot;small&quot;&#10;                            predictedLetter = event.letter.toString()&#10;                            isCorrectGesture = isCorrect&#10;                            &#10;                            // Send feedback to watch so it shows the same screen&#10;                            watchConnectionManager.sendLearnModeFeedback(isCorrect, event.letter.toString())&#10;                            &#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Setting showProgressCheckDialog = true for Write the Word/Name the Picture&quot;)&#10;                            showProgressCheckDialog = true&#10;&#10;                            // Store pending action to execute on dialog dismiss&#10;                            if (isCorrect) {&#10;                                val newLetterIndex = currentLetterIndex + 1&#10;                                pendingCorrectAction = {&#10;                                    // Mark letter as completed&#10;                                    completedLetterIndices = completedLetterIndices + currentLetterIndex&#10;                                    currentLetterIndex = newLetterIndex&#10;&#10;                                    if (newLetterIndex &gt;= currentWord.word.length) {&#10;                                        // Word complete - notify watch and move to next word&#10;                                        watchConnectionManager.sendWordComplete()&#10;&#10;                                        if (currentWordIndex &lt; words.size - 1) {&#10;                                            currentWordIndex++&#10;                                        } else {&#10;                                            // All items complete - notify watch before navigating away&#10;                                            watchConnectionManager.notifyActivityComplete()&#10;                                            onSessionComplete()&#10;                                        }&#10;                                    } else {&#10;                                        // Send correct result and move to next letter&#10;                                        watchConnectionManager.sendLetterResult(true, newLetterIndex, currentWord.word.length)&#10;                                    }&#10;                                }&#10;                            } else {&#10;                                pendingCorrectAction = {&#10;                                    // Wrong letter - send incorrect feedback but DON'T advance letter index&#10;                                    // User must retry the same letter until correct (case-sensitive)&#10;                                    watchConnectionManager.sendLetterResult(false, currentLetterIndex, currentWord.word.length)&#10;                                    // Resend word data so watch can prompt user to retry&#10;                                    watchConnectionManager.sendLearnModeWordData(&#10;                                        word = currentWord.word,&#10;                                        maskedIndex = currentWord.selectedLetterIndex,&#10;                                        configurationType = currentWord.configurationType&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Listen for feedback dismissal from watch&#10;    LaunchedEffect(Unit) {&#10;        var lastDismissTime = 0L&#10;        watchConnectionManager.learnModeFeedbackDismissed.collect { timestamp -&gt;&#10;            if (timestamp &gt; lastDismissTime &amp;&amp; timestamp &gt; 0L) {&#10;                lastDismissTime = timestamp&#10;                if (showProgressCheckDialog) {&#10;                    android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Watch dismissed feedback - dismissing mobile dialog&quot;)&#10;                    showProgressCheckDialog = false&#10;                    // Execute pending action&#10;                    pendingCorrectAction?.invoke()&#10;                    pendingCorrectAction = null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Listen for skip commands from watch with debouncing&#10;    LaunchedEffect(sessionKey) {&#10;        val sessionStartTime = System.currentTimeMillis()&#10;        var lastSkipTime = 0L&#10;        watchConnectionManager.learnModeSkipTrigger.collect { skipTime -&gt;&#10;            // Only process skip events that happened AFTER this session started (prevents stale events)&#10;            // and at least 500ms since last skip (debouncing)&#10;            val timeSinceLastSkip = skipTime - lastSkipTime&#10;            if (skipTime &gt; sessionStartTime &amp;&amp; skipTime &gt; lastSkipTime &amp;&amp; timeSinceLastSkip &gt;= 500) {&#10;                lastSkipTime = skipTime&#10;                onSkip()&#10;                if (currentWordIndex &lt; words.size - 1) {&#10;                    currentWordIndex++&#10;                } else {&#10;                    // All items complete - notify watch before navigating away&#10;                    watchConnectionManager.notifyActivityComplete()&#10;                    onSessionComplete()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Progress Check Dialog - show before loading check to ensure it always renders&#10;    if (showProgressCheckDialog) {&#10;        ProgressCheckDialog(&#10;            isCorrect = isCorrectGesture,&#10;            studentName = studentName,&#10;            targetLetter = targetLetter,&#10;            targetCase = targetCase,&#10;            predictedLetter = predictedLetter,&#10;            onDismiss = {&#10;                showProgressCheckDialog = false&#10;                // Notify watch that mobile dismissed feedback&#10;                watchConnectionManager.notifyLearnModeFeedbackDismissed()&#10;                // Execute pending action after dialog is dismissed&#10;                pendingCorrectAction?.invoke()&#10;                pendingCorrectAction = null&#10;            }&#10;        )&#10;    }&#10;&#10;    // Learner Profile Annotation Dialog&#10;    if (showAnnotationDialog) {&#10;        LearnerProfileAnnotationDialog(&#10;            studentName = studentName,&#10;            onDismiss = { showAnnotationDialog = false },&#10;            onAddNote = { levelOfProgress, strengthsObserved, strengthsNote, challenges, challengesNote -&gt;&#10;                // TODO: Save annotation data to database or send to analytics&#10;                android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Annotation saved: level=$levelOfProgress, strengths=$strengthsObserved, challenges=$challenges&quot;)&#10;            }&#10;        )&#10;    }&#10;&#10;    // Show loading&#10;    if (isLoading) {&#10;        Box(&#10;            modifier = modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator(color = PurpleColor)&#10;        }&#10;        return&#10;    }&#10;&#10;    val currentWord = words.getOrNull(currentWordIndex)&#10;    val totalWords = words.size.coerceAtLeast(1)&#10;    val currentStep = currentWordIndex + 1&#10;&#10;    // Function to handle skip/next&#10;    fun handleSkipOrNext() {&#10;        if (currentWordIndex &lt; words.size - 1) {&#10;            currentWordIndex++&#10;        } else {&#10;            // Session complete - notify watch and navigate away&#10;            watchConnectionManager.notifyActivityComplete()&#10;            onSessionComplete()&#10;        }&#10;    }&#10;&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 20.dp)&#10;            .padding(top = 40.dp, bottom = 24.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Progress Bar&#10;        ProgressIndicator(&#10;            currentStep = currentStep,&#10;            totalSteps = totalWords,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            activeColor = PurpleColor,&#10;            inactiveColor = LightPurpleColor&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        // Annotate and Skip Button Row&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Annotate button (left) - opens learner profile annotation dialog&#10;            IconButton(onClick = {&#10;                showAnnotationDialog = true&#10;                onAudioClick()&#10;            }) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.ic_annotate),&#10;                    contentDescription = &quot;Annotate&quot;,&#10;                    modifier = Modifier.size(28.dp),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;            }&#10;&#10;            // Skip button (right)&#10;            IconButton(onClick = {&#10;                onSkip()&#10;                handleSkipOrNext()&#10;            }) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.ic_skip),&#10;                    contentDescription = &quot;Skip&quot;,&#10;                    modifier = Modifier.size(28.dp),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        // Title&#10;        Text(&#10;            text = title,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.Black&#10;        )&#10;&#10;        // Activity Type Subtitle (dynamic from database)&#10;        Text(&#10;            text = currentWord?.configurationType ?: &quot;&quot;,&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Medium,&#10;            color = PurpleColor&#10;        )&#10;&#10;        Spacer(Modifier.height(24.dp))&#10;&#10;        // Centered content area (slightly raised)&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Top&#10;        ) {&#10;            Spacer(Modifier.weight(0.3f))&#10;            // Large Content Card with Image (Square) - only show if there's an image&#10;            if (currentWord?.imagePath != null) {&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.85f)&#10;                        .aspectRatio(1f),&#10;                    shape = RoundedCornerShape(24.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFFFBF9FF)&#10;                    ),&#10;                    border = BorderStroke(4.dp, Color(0xFFAE8EFB))&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Image(&#10;                            painter = rememberAsyncImagePainter(&#10;                                ImageRequest.Builder(context)&#10;                                    .data(File(currentWord.imagePath))&#10;                                    .crossfade(true)&#10;                                    .build()&#10;                            ),&#10;                            contentDescription = &quot;Word image&quot;,&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(16.dp),&#10;                            contentScale = ContentScale.Fit&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Extra spacing for cards to push text/dashes lower&#10;                val isNameThePicture = currentWord.configurationType == &quot;Name the Picture&quot;&#10;                val isFillInTheBlanks = currentWord.configurationType == &quot;Fill in the Blank&quot;&#10;                if (isNameThePicture || isFillInTheBlanks) {&#10;                    Spacer(Modifier.height(48.dp))&#10;                } else {&#10;                    Spacer(Modifier.height(24.dp))&#10;                }&#10;            }&#10;&#10;            // Masked Word Display (e.g., &quot;D _ G&quot;) or Full Word Display for &quot;Write the Word&quot; or Blank for &quot;Name the Picture&quot;&#10;            if (currentWord != null) {&#10;                val isWriteTheWord = currentWord.configurationType == &quot;Write the Word&quot;&#10;                val isNameThePicture = currentWord.configurationType == &quot;Name the Picture&quot;&#10;                val isFillInTheBlank = currentWord.configurationType == &quot;Fill in the Blank&quot;&#10;&#10;                when {&#10;                    isWriteTheWord -&gt; {&#10;                        // Write the Word mode - show letters with color based on completion&#10;                        WriteTheWordDisplay(&#10;                            word = currentWord.word,&#10;                            completedIndices = completedLetterIndices,&#10;                            currentIndex = currentLetterIndex,&#10;                            hasImage = currentWord.imagePath != null&#10;                        )&#10;                    }&#10;                    isFillInTheBlank -&gt; {&#10;                        // Fill in the Blank mode - show masked word, reveal correct letter in violet when answered&#10;                        FillInTheBlankDisplay(&#10;                            word = currentWord.word,&#10;                            maskedIndex = currentWord.selectedLetterIndex,&#10;                            isCorrect = fillInBlankCorrect,&#10;                            hasImage = currentWord.imagePath != null&#10;                        )&#10;                    }&#10;                    isNameThePicture -&gt; {&#10;                        // Name the Picture mode - show blanks that reveal letters when correct&#10;                        NameThePictureDisplay(&#10;                            word = currentWord.word,&#10;                            completedIndices = completedLetterIndices,&#10;                            currentIndex = currentLetterIndex,&#10;                            hasImage = currentWord.imagePath != null&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        Text(&#10;                            text = currentWord.getMaskedWord(),&#10;                            fontSize = if (currentWord.imagePath != null) 48.sp else 96.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Black,&#10;                            letterSpacing = if (currentWord.imagePath != null) 4.sp else 8.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(0.7f))&#10;        }&#10;&#10;        Spacer(Modifier.height(24.dp))&#10;    }&#10;}&#10;&#10;/**&#10; * Display for Write the Word mode showing each letter with color based on completion status.&#10; * Current letter has an underline. Completed letters turn purple (#AE8EFB), pending letters are gray.&#10; */&#10;@Composable&#10;private fun WriteTheWordDisplay(&#10;    word: String,&#10;    completedIndices: Set&lt;Int&gt;,&#10;    currentIndex: Int,&#10;    hasImage: Boolean&#10;) {&#10;    val fontSize = if (hasImage) 48.sp else 96.sp&#10;    val letterSpacing = if (hasImage) 12.dp else 16.dp&#10;&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(letterSpacing),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        word.forEachIndexed { index, letter -&gt;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = letter.toString(),&#10;                    fontSize = fontSize,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = when {&#10;                        index in completedIndices -&gt; CompletedLetterColor  // Completed - purple&#10;                        else -&gt; PendingLetterColor  // Pending letters - gray&#10;                    }&#10;                )&#10;&#10;                // Add underline for current letter being input&#10;                if (index == currentIndex) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .width(fontSize.value.dp * 0.7f)&#10;                            .height(4.dp)&#10;                            .background(Color.Black, RoundedCornerShape(2.dp))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Display for Fill in the Blank mode showing the word with a masked letter.&#10; * When the correct letter is written, it's revealed in violet/purple color.&#10; * Uses the same underline style as Write the Word for consistency.&#10; */&#10;@Composable&#10;private fun FillInTheBlankDisplay(&#10;    word: String,&#10;    maskedIndex: Int,&#10;    isCorrect: Boolean,&#10;    hasImage: Boolean&#10;) {&#10;    val fontSize = if (hasImage) 48.sp else 96.sp&#10;    val letterSpacing = if (hasImage) 12.dp else 16.dp&#10;&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(letterSpacing),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        word.forEachIndexed { index, letter -&gt;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = if (index == maskedIndex &amp;&amp; !isCorrect) &quot; &quot; else letter.toString(),&#10;                    fontSize = fontSize,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = when {&#10;                        index == maskedIndex &amp;&amp; isCorrect -&gt; CompletedLetterColor  // Revealed - purple&#10;                        else -&gt; Color.Black  // Other letters - black&#10;                    }&#10;                )&#10;&#10;                // Add underline for the masked letter (current letter being input)&#10;                if (index == maskedIndex &amp;&amp; !isCorrect) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .width(fontSize.value.dp * 0.7f)&#10;                            .height(4.dp)&#10;                            .background(Color.Black, RoundedCornerShape(2.dp))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Display for Name the Picture mode showing blanks initially.&#10; * Completed letters are revealed in purple, pending letters show as underlines.&#10; * Current letter has an underline (same style as Write the Word).&#10; */&#10;@Composable&#10;private fun NameThePictureDisplay(&#10;    word: String,&#10;    completedIndices: Set&lt;Int&gt;,&#10;    currentIndex: Int,&#10;    hasImage: Boolean&#10;) {&#10;    val fontSize = if (hasImage) 48.sp else 96.sp&#10;    val letterSpacing = if (hasImage) 12.dp else 16.dp&#10;&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(letterSpacing),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        word.forEachIndexed { index, letter -&gt;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = if (index in completedIndices) letter.toString() else &quot; &quot;,&#10;                    fontSize = fontSize,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (index in completedIndices) CompletedLetterColor else Color.Transparent&#10;                )&#10;&#10;                // Add underline for letters not yet completed&#10;                if (index !in completedIndices) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .width(fontSize.value.dp * 0.7f)&#10;                            .height(4.dp)&#10;                            .background(Color.Black, RoundedCornerShape(2.dp))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProgressIndicator(&#10;    currentStep: Int,&#10;    totalSteps: Int,&#10;    modifier: Modifier = Modifier,&#10;    activeColor: Color = PurpleColor,&#10;    inactiveColor: Color = LightPurpleColor&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        repeat(totalSteps) { index -&gt;&#10;            val isActive = index &lt; currentStep&#10;            Box(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .height(8.dp)&#10;                    .clip(RoundedCornerShape(4.dp))&#10;                    .background(&#10;                        if (isActive) activeColor else inactiveColor&#10;                    )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun LearnModeSessionScreenPreview() {&#10;    LearnModeSessionScreen(&#10;        setId = 0L,&#10;        activityTitle = &quot;Vowels&quot;,&#10;        sessionKey = 0&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;private fun ProgressCheckDialog(&#10;    isCorrect: Boolean,&#10;    studentName: String,&#10;    targetLetter: String,&#10;    targetCase: String,&#10;    predictedLetter: String,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    // Extract first name only for more friendly tone&#10;    val firstName = studentName.split(&quot; &quot;).firstOrNull()?.takeIf { it.isNotEmpty() } ?: &quot;&quot;&#10;&#10;    // Define similar shape letters (same as watch side)&#10;    val similarShapeLetters = setOf('C', 'K', 'O', 'P', 'S', 'V', 'W', 'X', 'Z')&#10;&#10;    // Check if there's a case mismatch for similar letters&#10;    val targetUppercase = targetLetter.uppercase()&#10;    val isSimilarShape = targetUppercase.firstOrNull() in similarShapeLetters&#10;    val expectedCase = when (targetCase.lowercase()) {&#10;        &quot;small&quot;, &quot;lowercase&quot; -&gt; targetLetter.lowercase()&#10;        else -&gt; targetLetter.uppercase()&#10;    }&#10;    val hasCaseMismatch = isCorrect &amp;&amp; isSimilarShape &amp;&amp;&#10;                         predictedLetter.isNotEmpty() &amp;&amp;&#10;                         !predictedLetter.equals(expectedCase, ignoreCase = false)&#10;&#10;    Dialog(&#10;        onDismissRequest = onDismiss,&#10;        properties = DialogProperties(usePlatformDefaultWidth = false)&#10;    ) {&#10;        // Full-screen dark overlay&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black.copy(alpha = 0.7f))&#10;                .clickable(&#10;                    indication = null,&#10;                    interactionSource = remember { MutableInteractionSource() }&#10;                ) { onDismiss() },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.85f)&#10;                    .wrapContentHeight(),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                // Mascot Image&#10;                Image(&#10;                    painter = painterResource(&#10;                        id = if (isCorrect) R.drawable.dis_mobile_correct else R.drawable.dis_mobile_incorrect&#10;                    ),&#10;                    contentDescription = if (isCorrect) &quot;Correct&quot; else &quot;Incorrect&quot;,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.7f)&#10;                        .aspectRatio(1f),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;&#10;                Spacer(Modifier.height(24.dp))&#10;&#10;                // Title with first name only&#10;                Text(&#10;                    text = if (isCorrect) {&#10;                        &quot;Great Job${if (firstName.isNotEmpty()) &quot;, $firstName&quot; else &quot;&quot;}!&quot;&#10;                    } else {&#10;                        &quot;Not quite${if (firstName.isNotEmpty()) &quot;, $firstName&quot; else &quot;&quot;}!&quot;&#10;                    },&#10;                    fontSize = 28.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (isCorrect) Color(0xFFCCDB00) else Color(0xFFFF6B6B),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Spacer(Modifier.height(12.dp))&#10;&#10;                // Body text with optional case mismatch disclaimer&#10;                if (isCorrect &amp;&amp; hasCaseMismatch) {&#10;                    Text(&#10;                        text = &quot;You're doing super!\nKeep up the amazing work!&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 24.sp&#10;                    )&#10;&#10;                    Spacer(Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Psst... you wrote ${if (predictedLetter.first().isUpperCase()) &quot;uppercase&quot; else &quot;lowercase&quot;} ${predictedLetter.uppercase()}, &quot; +&#10;                              &quot;but we're practicing ${if (targetCase.lowercase() in listOf(&quot;small&quot;, &quot;lowercase&quot;)) &quot;lowercase&quot; else &quot;uppercase&quot;} letters! &quot; +&#10;                              &quot;They look similar, so that's still great! &quot;,&#10;                        fontSize = 14.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White.copy(alpha = 0.9f),&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 20.sp&#10;                    )&#10;                } else if (isCorrect) {&#10;                    Text(&#10;                        text = &quot;You're doing super!\nKeep up the amazing work!&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 24.sp&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = &quot;Let's give it another go!&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 24.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Data class representing a selectable chip option&#10; */&#10;private data class ChipOption(&#10;    val label: String,&#10;    val color: Color,&#10;    val isSelected: Boolean = false&#10;)&#10;&#10;/**&#10; * Learner Profile Annotation Dialog&#10; * Shows when the annotate button is clicked to allow teachers to record observations&#10; * Features scrollable content and smooth slide-up animation&#10; */&#10;@Composable&#10;private fun LearnerProfileAnnotationDialog(&#10;    studentName: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onAddNote: (&#10;        levelOfProgress: String?,&#10;        strengthsObserved: List&lt;String&gt;,&#10;        strengthsNote: String,&#10;        challenges: List&lt;String&gt;,&#10;        challengesNote: String&#10;    ) -&gt; Unit&#10;) {&#10;    // Animation state for slide-up/down effect&#10;    var isVisible by remember { mutableStateOf(false) }&#10;    var isClosing by remember { mutableStateOf(false) }&#10;&#10;    val slideOffset by androidx.compose.animation.core.animateFloatAsState(&#10;        targetValue = if (isVisible &amp;&amp; !isClosing) 0f else 1f,&#10;        animationSpec = androidx.compose.animation.core.tween(&#10;            durationMillis = 300,&#10;            easing = if (isClosing)&#10;                androidx.compose.animation.core.FastOutLinearInEasing&#10;            else&#10;                androidx.compose.animation.core.FastOutSlowInEasing&#10;        ),&#10;        finishedListener = {&#10;            if (isClosing) {&#10;                onDismiss()&#10;            }&#10;        },&#10;        label = &quot;slideOffset&quot;&#10;    )&#10;    val backgroundAlpha by androidx.compose.animation.core.animateFloatAsState(&#10;        targetValue = if (isVisible &amp;&amp; !isClosing) 0.5f else 0f,&#10;        animationSpec = androidx.compose.animation.core.tween(&#10;            durationMillis = 300&#10;        ),&#10;        label = &quot;backgroundAlpha&quot;&#10;    )&#10;&#10;    // Function to trigger close animation&#10;    val animateClose: () -&gt; Unit = {&#10;        isClosing = true&#10;    }&#10;&#10;    // Trigger animation when dialog appears&#10;    LaunchedEffect(Unit) {&#10;        isVisible = true&#10;    }&#10;&#10;    // Level of Progress options&#10;    val levelOptions = listOf(&#10;        ChipOption(&quot;Beginning&quot;, Color(0xFFFF6B6B)),&#10;        ChipOption(&quot;Developing&quot;, Color(0xFFFFB800)),&#10;        ChipOption(&quot;Proficient&quot;, Color(0xFF4CAF50)),&#10;        ChipOption(&quot;Advanced&quot;, Color(0xFF2196F3))&#10;    )&#10;    var selectedLevel by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Strengths Observed options&#10;    val strengthOptions = listOf(&quot;Recognition&quot;, &quot;Fluency&quot;, &quot;Formation&quot;)&#10;    var selectedStrengths by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }&#10;    var strengthsNote by remember { mutableStateOf(&quot;&quot;) }&#10;    var showStrengthsNoteField by remember { mutableStateOf(false) }&#10;&#10;    // Challenges options&#10;    val challengeOptions = listOf(&quot;Recognition&quot;, &quot;Fluency&quot;, &quot;Formation&quot;)&#10;    var selectedChallenges by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }&#10;    var challengesNote by remember { mutableStateOf(&quot;&quot;) }&#10;    var showChallengesNoteField by remember { mutableStateOf(false) }&#10;&#10;    // Scroll state for content&#10;    val scrollState = androidx.compose.foundation.rememberScrollState()&#10;&#10;    Dialog(&#10;        onDismissRequest = animateClose,&#10;        properties = DialogProperties(usePlatformDefaultWidth = false)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black.copy(alpha = backgroundAlpha))&#10;                .clickable(&#10;                    indication = null,&#10;                    interactionSource = remember { MutableInteractionSource() }&#10;                ) { animateClose() },&#10;            contentAlignment = Alignment.BottomCenter&#10;        ) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .fillMaxHeight(0.75f)&#10;                    .offset(y = (slideOffset * 600).dp)&#10;                    .clickable(&#10;                        indication = null,&#10;                        interactionSource = remember { MutableInteractionSource() }&#10;                    ) { /* Prevent click through */ },&#10;                shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.White)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                ) {&#10;                    // Fixed Header with icon and student name&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(start = 24.dp, end = 24.dp, top = 24.dp, bottom = 16.dp)&#10;                    ) {&#10;                        // Drag handle indicator&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .align(Alignment.CenterHorizontally)&#10;                                .width(40.dp)&#10;                                .height(4.dp)&#10;                                .clip(RoundedCornerShape(2.dp))&#10;                                .background(Color.LightGray)&#10;                        )&#10;&#10;                        Spacer(Modifier.height(16.dp))&#10;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            Image(&#10;                                painter = painterResource(id = R.drawable.ic_annotate),&#10;                                contentDescription = &quot;Profile&quot;,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                            Spacer(Modifier.width(12.dp))&#10;                            Text(&#10;                                text = &quot;Learner Profile: $studentName&quot;,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = Color.Black&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Scrollable content&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .verticalScroll(scrollState)&#10;                            .padding(horizontal = 24.dp)&#10;                    ) {&#10;                        // Level of Progress section&#10;                        Text(&#10;                            text = &quot;Level of Progress&quot;,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        // Level chips - first row&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            levelOptions.take(3).forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option.label,&#10;                                    dotColor = option.color,&#10;                                    isSelected = selectedLevel == option.label,&#10;                                    onClick = {&#10;                                        selectedLevel = if (selectedLevel == option.label) null else option.label&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                        Spacer(Modifier.height(8.dp))&#10;                        // Level chips - second row&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            levelOptions.drop(3).forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option.label,&#10;                                    dotColor = option.color,&#10;                                    isSelected = selectedLevel == option.label,&#10;                                    onClick = {&#10;                                        selectedLevel = if (selectedLevel == option.label) null else option.label&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(24.dp))&#10;&#10;                        // Strengths Observed section&#10;                        Text(&#10;                            text = &quot;Strengths Observed&quot;,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            strengthOptions.forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option,&#10;                                    dotColor = Color(0xFF2196F3),&#10;                                    isSelected = option in selectedStrengths,&#10;                                    onClick = {&#10;                                        selectedStrengths = if (option in selectedStrengths) {&#10;                                            selectedStrengths - option&#10;                                        } else {&#10;                                            selectedStrengths + option&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(8.dp))&#10;&#10;                        // Add Note for Strengths&#10;                        if (showStrengthsNoteField) {&#10;                            androidx.compose.material3.OutlinedTextField(&#10;                                value = strengthsNote,&#10;                                onValueChange = { strengthsNote = it },&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                placeholder = { Text(&quot;Add a note...&quot;, color = Color.Gray) },&#10;                                colors = androidx.compose.material3.OutlinedTextFieldDefaults.colors(&#10;                                    focusedBorderColor = PurpleColor,&#10;                                    unfocusedBorderColor = Color.LightGray&#10;                                ),&#10;                                minLines = 2,&#10;                                maxLines = 4&#10;                            )&#10;                        } else {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .clickable { showStrengthsNoteField = true }&#10;                                    .padding(vertical = 8.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;+ Add Note&quot;,&#10;                                    fontSize = 14.sp,&#10;                                    color = PurpleColor&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(24.dp))&#10;&#10;                        // Challenges section&#10;                        Text(&#10;                            text = &quot;Challenges&quot;,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(Modifier.height(12.dp))&#10;&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            challengeOptions.forEach { option -&gt;&#10;                                SelectableChip(&#10;                                    label = option,&#10;                                    dotColor = Color(0xFF2196F3),&#10;                                    isSelected = option in selectedChallenges,&#10;                                    onClick = {&#10;                                        selectedChallenges = if (option in selectedChallenges) {&#10;                                            selectedChallenges - option&#10;                                        } else {&#10;                                            selectedChallenges + option&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(Modifier.height(8.dp))&#10;&#10;                        // Add Note for Challenges&#10;                        if (showChallengesNoteField) {&#10;                            androidx.compose.material3.OutlinedTextField(&#10;                                value = challengesNote,&#10;                                onValueChange = { challengesNote = it },&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                placeholder = { Text(&quot;Add a note...&quot;, color = Color.Gray) },&#10;                                colors = androidx.compose.material3.OutlinedTextFieldDefaults.colors(&#10;                                    focusedBorderColor = PurpleColor,&#10;                                    unfocusedBorderColor = Color.LightGray&#10;                                ),&#10;                                minLines = 2,&#10;                                maxLines = 4&#10;                            )&#10;                        } else {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .clickable { showChallengesNoteField = true }&#10;                                    .padding(vertical = 8.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;+ Add Note&quot;,&#10;                                    fontSize = 14.sp,&#10;                                    color = PurpleColor&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        // Bottom padding for scroll content&#10;                        Spacer(Modifier.height(24.dp))&#10;                    }&#10;&#10;                    // Fixed Add Note button at bottom&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .background(Color.White)&#10;                            .padding(24.dp)&#10;                    ) {&#10;                        androidx.compose.material3.Button(&#10;                            onClick = {&#10;                                onAddNote(&#10;                                    selectedLevel,&#10;                                    selectedStrengths.toList(),&#10;                                    strengthsNote,&#10;                                    selectedChallenges.toList(),&#10;                                    challengesNote&#10;                                )&#10;                                onDismiss()&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(56.dp),&#10;                            shape = RoundedCornerShape(16.dp),&#10;                            colors = androidx.compose.material3.ButtonDefaults.buttonColors(&#10;                                containerColor = Color(0xFF4A90D9)&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Add Note&quot;,&#10;                                fontSize = 16.sp,&#10;                                fontWeight = FontWeight.SemiBold,&#10;                                color = Color.White&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Selectable chip with colored dot indicator&#10; */&#10;@Composable&#10;private fun SelectableChip(&#10;    label: String,&#10;    dotColor: Color,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    val borderColor = if (isSelected) PurpleColor else Color(0xFFE0E0E0)&#10;    val backgroundColor = if (isSelected) PurpleColor.copy(alpha = 0.1f) else Color.White&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(20.dp),&#10;        colors = CardDefaults.cardColors(containerColor = backgroundColor),&#10;        border = BorderStroke(1.dp, borderColor)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;        ) {&#10;            // Colored dot&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(8.dp)&#10;                    .clip(RoundedCornerShape(50))&#10;                    .background(dotColor)&#10;            )&#10;            Text(&#10;                text = label,&#10;                fontSize = 13.sp,&#10;                color = Color.Black&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.learnmode&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import coil.compose.rememberAsyncImagePainter&#10;import coil.request.ImageRequest&#10;import com.example.app.R&#10;import com.example.app.data.AppDatabase&#10;import com.example.app.data.repository.SetRepository&#10;import com.example.app.service.WatchConnectionManager&#10;import com.example.app.ui.components.LearnerProfileAnnotationDialog&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;private val PurpleColor = Color(0xFFAE8EFB)&#10;private val LightPurpleColor = Color(0xFFE7DDFE)&#10;private val CompletedLetterColor = Color(0xFFAE8EFB)&#10;private val PendingLetterColor = Color(0xFF808080)&#10;&#10;/**&#10; * Letters that have very similar writing structures between uppercase and lowercase&#10; * in air writing. These letters should be checked case-insensitively.&#10; */&#10;private val similarCaseLetters = setOf('c', 'k', 'o', 'p', 's', 'u', 'v', 'w', 'x', 'z',&#10;                                       'C', 'K', 'O', 'P', 'S', 'U', 'V', 'W', 'X', 'Z')&#10;&#10;/**&#10; * Check if the input letter matches the expected letter.&#10; * For letters with similar writing structures (c, k, o, p, s, u, v, w, x, z),&#10; * the comparison is case-insensitive.&#10; * For other letters, the comparison is case-sensitive.&#10; */&#10;private fun isLetterMatch(inputLetter: Char?, expectedLetter: Char?): Boolean {&#10;    if (inputLetter == null || expectedLetter == null) return false&#10;&#10;    // If the expected letter is one with similar case writing structure, compare case-insensitively&#10;    return if (expectedLetter in similarCaseLetters) {&#10;        inputLetter.lowercaseChar() == expectedLetter.lowercaseChar()&#10;    } else {&#10;        inputLetter == expectedLetter&#10;    }&#10;}&#10;&#10;/**&#10; * Data class representing a word item in the learn mode session.&#10; */&#10;private data class WordItem(&#10;    val word: String,&#10;    val selectedLetterIndex: Int,&#10;    val imagePath: String?,&#10;    val configurationType: String&#10;) {&#10;    fun getMaskedWord(): String {&#10;        return word.mapIndexed { index, char -&gt;&#10;            if (index == selectedLetterIndex) &quot;_&quot; else char&#10;        }.joinToString(&quot; &quot;)&#10;    }&#10;&#10;    fun getFullWord(): String {&#10;        return word.toList().joinToString(&quot; &quot;)&#10;    }&#10;&#10;    fun getBlankWord(): String {&#10;        return word.map { &quot;â–¬&quot; }.joinToString(&quot;  &quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LearnModeSessionScreen(&#10;    setId: Long = 0L,&#10;    activityTitle: String = &quot;&quot;,&#10;    sessionKey: Int = 0,&#10;    studentName: String = &quot;&quot;,&#10;    modifier: Modifier = Modifier,&#10;    onSkip: () -&gt; Unit = {},&#10;    onAudioClick: () -&gt; Unit = {},&#10;    onSessionComplete: () -&gt; Unit = {}&#10;) {&#10;    // Local state - fresh on each recomposition with new sessionKey&#10;    var isLoading by remember(sessionKey) { mutableStateOf(true) }&#10;    var words by remember(sessionKey) { mutableStateOf&lt;List&lt;WordItem&gt;&gt;(emptyList()) }&#10;    var currentWordIndex by remember(sessionKey) { mutableIntStateOf(0) }&#10;    var title by remember(sessionKey) { mutableStateOf(activityTitle) }&#10;&#10;    // State for Write the Word mode - tracks which letters have been correctly input&#10;    var completedLetterIndices by remember(sessionKey) { mutableStateOf&lt;Set&lt;Int&gt;&gt;(emptySet()) }&#10;    var currentLetterIndex by remember(sessionKey) { mutableIntStateOf(0) }&#10;&#10;    // State for Fill in the Blank mode - tracks if the masked letter has been correctly answered&#10;    var fillInBlankCorrect by remember(sessionKey) { mutableStateOf(false) }&#10;&#10;    // State for ProgressCheckDialog&#10;    var showProgressCheckDialog by remember(sessionKey) { mutableStateOf(false) }&#10;    var isCorrectGesture by remember(sessionKey) { mutableStateOf(false) }&#10;    var predictedLetter by remember(sessionKey) { mutableStateOf(&quot;&quot;) }&#10;    var targetLetter by remember(sessionKey) { mutableStateOf(&quot;&quot;) }&#10;    var targetCase by remember(sessionKey) { mutableStateOf(&quot;&quot;) }&#10;    &#10;    // Store pending state changes to apply after dialog dismissal&#10;    var pendingCorrectAction by remember(sessionKey) { mutableStateOf&lt;(() -&gt; Unit)?&gt;(null) }&#10;&#10;    // State for Learner Profile Annotation Dialog&#10;    var showAnnotationDialog by remember(sessionKey) { mutableStateOf(false) }&#10;&#10;    val context = LocalContext.current&#10;&#10;    // Get WatchConnectionManager instance&#10;    val watchConnectionManager = remember { WatchConnectionManager.getInstance(context) }&#10;    &#10;    // Notify watch when Learn Mode session starts&#10;    LaunchedEffect(sessionKey) {&#10;        watchConnectionManager.notifyLearnModeStarted()&#10;    }&#10;    &#10;    // Note: We don't call notifyLearnModeEnded() here on dispose anymore&#10;    // because we want the watch to keep showing the completion screen&#10;    // while the phone shows the analytics screen.&#10;    // notifyLearnModeEnded() is now called from LearnModeSessionAnalyticsScreen&#10;    // when the user leaves (Practice Again or Continue).&#10;&#10;    // Load data when screen opens - using sessionKey as key ensures this runs fresh each time&#10;    LaunchedEffect(setId, sessionKey) {&#10;        if (setId &gt; 0) {&#10;            isLoading = true&#10;            try {&#10;                val database = AppDatabase.getInstance(context)&#10;                val setRepository = SetRepository(&#10;                    database.setDao(),&#10;                    database.setWordDao(),&#10;                    database.wordDao()&#10;                )&#10;&#10;                val setDetails = withContext(Dispatchers.IO) {&#10;                    setRepository.getSetDetails(setId)&#10;                }&#10;&#10;                if (setDetails != null) {&#10;                    words = setDetails.words.map { wordConfig -&gt;&#10;                        WordItem(&#10;                            word = wordConfig.word,&#10;                            selectedLetterIndex = wordConfig.selectedLetterIndex,&#10;                            imagePath = wordConfig.imagePath,&#10;                            configurationType = wordConfig.configurationType&#10;                        )&#10;                    }&#10;                    title = activityTitle&#10;                }&#10;            } catch (e: Exception) {&#10;                // Handle error silently&#10;            } finally {&#10;                isLoading = false&#10;            }&#10;        } else {&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    // Send current word data to watch whenever current word changes&#10;    LaunchedEffect(currentWordIndex, words) {&#10;        val currentWord = words.getOrNull(currentWordIndex)&#10;        if (currentWord != null) {&#10;            // Reset letter tracking state for new word&#10;            completedLetterIndices = emptySet()&#10;            currentLetterIndex = 0&#10;            fillInBlankCorrect = false&#10;&#10;            watchConnectionManager.sendLearnModeWordData(&#10;                word = currentWord.word,&#10;                maskedIndex = currentWord.selectedLetterIndex,&#10;                configurationType = currentWord.configurationType&#10;            )&#10;        }&#10;    }&#10;&#10;    // Listen for letter input events from watch (for Write the Word, Name the Picture, and Fill in the Blank modes)&#10;    LaunchedEffect(Unit) {&#10;        var lastEventTime = 0L&#10;        watchConnectionManager.letterInputEvent.collect { event -&gt;&#10;            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Received letterInputEvent: letter=${event.letter}, timestamp=${event.timestamp}, lastEventTime=$lastEventTime&quot;)&#10;&#10;            // Process event only if timestamp is valid (&gt; 0) and newer than last processed event&#10;            if (event.timestamp &gt; 0L &amp;&amp; event.timestamp &gt; lastEventTime) {&#10;                lastEventTime = event.timestamp&#10;                val currentWord = words.getOrNull(currentWordIndex)&#10;                android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Processing event: currentWord=${currentWord?.word}, type=${currentWord?.configurationType}, currentWordIndex=$currentWordIndex&quot;)&#10;                if (currentWord != null) {&#10;                    when (currentWord.configurationType) {&#10;                        &quot;Fill in the Blank&quot; -&gt; {&#10;                            // For Fill in the Blank, check if the masked letter is correct&#10;                            val expectedLetter = currentWord.word.getOrNull(currentWord.selectedLetterIndex)&#10;                            // Use case-insensitive matching for similar letters (c, k, o, p, s, u, v, w, x, z)&#10;                            val isCorrect = isLetterMatch(event.letter, expectedLetter)&#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Fill in the Blank: input=${event.letter}, expected=$expectedLetter, isCorrect=$isCorrect&quot;)&#10;&#10;                            // Set up dialog state&#10;                            targetLetter = expectedLetter?.toString() ?: &quot;&quot;&#10;                            targetCase = if (expectedLetter?.isUpperCase() == true) &quot;capital&quot; else &quot;small&quot;&#10;                            predictedLetter = event.letter.toString()&#10;                            isCorrectGesture = isCorrect&#10;                            &#10;                            // Send feedback to watch so it shows the same screen&#10;                            watchConnectionManager.sendLearnModeFeedback(isCorrect, event.letter.toString())&#10;&#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Setting showProgressCheckDialog = true for Fill in the Blank&quot;)&#10;                            showProgressCheckDialog = true&#10;&#10;                            // Store pending action to execute on dialog dismiss&#10;                            if (isCorrect) {&#10;                                pendingCorrectAction = {&#10;                                    // Mark Fill in the Blank as correct to reveal the letter&#10;                                    fillInBlankCorrect = true&#10;                                    &#10;                                    // Correct answer - notify watch and move to next word&#10;                                    watchConnectionManager.sendWordComplete()&#10;                                    &#10;                                    if (currentWordIndex &lt; words.size - 1) {&#10;                                        currentWordIndex++&#10;                                    } else {&#10;                                        // All items complete - notify watch before navigating away&#10;                                        watchConnectionManager.notifyActivityComplete()&#10;                                        onSessionComplete()&#10;                                    }&#10;                                }&#10;                            } else {&#10;                                pendingCorrectAction = {&#10;                                    // Wrong letter - send incorrect feedback and resend word data for retry&#10;                                    watchConnectionManager.sendLetterResult(false, currentWord.selectedLetterIndex, currentWord.word.length)&#10;                                    // Resend word data so watch can prompt user to retry&#10;                                    watchConnectionManager.sendLearnModeWordData(&#10;                                        word = currentWord.word,&#10;                                        maskedIndex = currentWord.selectedLetterIndex,&#10;                                        configurationType = currentWord.configurationType&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                        &quot;Write the Word&quot;, &quot;Name the Picture&quot; -&gt; {&#10;                            // Get expected letter&#10;                            val expectedLetter = currentWord.word.getOrNull(currentLetterIndex)&#10;&#10;                            // Check if input letter matches expected letter&#10;                            // Uses case-insensitive matching for similar letters (c, k, o, p, s, u, v, w, x, z)&#10;                            val isCorrect = isLetterMatch(event.letter, expectedLetter)&#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Write the Word/Name the Picture: input=${event.letter}, expected=$expectedLetter, isCorrect=$isCorrect&quot;)&#10;&#10;                            // Set up dialog state&#10;                            targetLetter = expectedLetter?.toString() ?: &quot;&quot;&#10;                            targetCase = if (expectedLetter?.isUpperCase() == true) &quot;capital&quot; else &quot;small&quot;&#10;                            predictedLetter = event.letter.toString()&#10;                            isCorrectGesture = isCorrect&#10;                            &#10;                            // Send feedback to watch so it shows the same screen&#10;                            watchConnectionManager.sendLearnModeFeedback(isCorrect, event.letter.toString())&#10;                            &#10;                            android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Setting showProgressCheckDialog = true for Write the Word/Name the Picture&quot;)&#10;                            showProgressCheckDialog = true&#10;&#10;                            // Store pending action to execute on dialog dismiss&#10;                            if (isCorrect) {&#10;                                val newLetterIndex = currentLetterIndex + 1&#10;                                pendingCorrectAction = {&#10;                                    // Mark letter as completed&#10;                                    completedLetterIndices = completedLetterIndices + currentLetterIndex&#10;                                    currentLetterIndex = newLetterIndex&#10;&#10;                                    if (newLetterIndex &gt;= currentWord.word.length) {&#10;                                        // Word complete - notify watch and move to next word&#10;                                        watchConnectionManager.sendWordComplete()&#10;&#10;                                        if (currentWordIndex &lt; words.size - 1) {&#10;                                            currentWordIndex++&#10;                                        } else {&#10;                                            // All items complete - notify watch before navigating away&#10;                                            watchConnectionManager.notifyActivityComplete()&#10;                                            onSessionComplete()&#10;                                        }&#10;                                    } else {&#10;                                        // Send correct result and move to next letter&#10;                                        watchConnectionManager.sendLetterResult(true, newLetterIndex, currentWord.word.length)&#10;                                    }&#10;                                }&#10;                            } else {&#10;                                pendingCorrectAction = {&#10;                                    // Wrong letter - send incorrect feedback but DON'T advance letter index&#10;                                    // User must retry the same letter until correct (case-sensitive)&#10;                                    watchConnectionManager.sendLetterResult(false, currentLetterIndex, currentWord.word.length)&#10;                                    // Resend word data so watch can prompt user to retry&#10;                                    watchConnectionManager.sendLearnModeWordData(&#10;                                        word = currentWord.word,&#10;                                        maskedIndex = currentWord.selectedLetterIndex,&#10;                                        configurationType = currentWord.configurationType&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Listen for feedback dismissal from watch&#10;    LaunchedEffect(Unit) {&#10;        var lastDismissTime = 0L&#10;        watchConnectionManager.learnModeFeedbackDismissed.collect { timestamp -&gt;&#10;            if (timestamp &gt; lastDismissTime &amp;&amp; timestamp &gt; 0L) {&#10;                lastDismissTime = timestamp&#10;                if (showProgressCheckDialog) {&#10;                    android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Watch dismissed feedback - dismissing mobile dialog&quot;)&#10;                    showProgressCheckDialog = false&#10;                    // Execute pending action&#10;                    pendingCorrectAction?.invoke()&#10;                    pendingCorrectAction = null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Listen for skip commands from watch with debouncing&#10;    LaunchedEffect(sessionKey) {&#10;        val sessionStartTime = System.currentTimeMillis()&#10;        var lastSkipTime = 0L&#10;        watchConnectionManager.learnModeSkipTrigger.collect { skipTime -&gt;&#10;            // Only process skip events that happened AFTER this session started (prevents stale events)&#10;            // and at least 500ms since last skip (debouncing)&#10;            val timeSinceLastSkip = skipTime - lastSkipTime&#10;            if (skipTime &gt; sessionStartTime &amp;&amp; skipTime &gt; lastSkipTime &amp;&amp; timeSinceLastSkip &gt;= 500) {&#10;                lastSkipTime = skipTime&#10;                onSkip()&#10;                if (currentWordIndex &lt; words.size - 1) {&#10;                    currentWordIndex++&#10;                } else {&#10;                    // All items complete - notify watch before navigating away&#10;                    watchConnectionManager.notifyActivityComplete()&#10;                    onSessionComplete()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Progress Check Dialog - show before loading check to ensure it always renders&#10;    if (showProgressCheckDialog) {&#10;        ProgressCheckDialog(&#10;            isCorrect = isCorrectGesture,&#10;            studentName = studentName,&#10;            targetLetter = targetLetter,&#10;            targetCase = targetCase,&#10;            predictedLetter = predictedLetter,&#10;            onDismiss = {&#10;                showProgressCheckDialog = false&#10;                // Notify watch that mobile dismissed feedback&#10;                watchConnectionManager.notifyLearnModeFeedbackDismissed()&#10;                // Execute pending action after dialog is dismissed&#10;                pendingCorrectAction?.invoke()&#10;                pendingCorrectAction = null&#10;            }&#10;        )&#10;    }&#10;&#10;    // Learner Profile Annotation Dialog&#10;    if (showAnnotationDialog) {&#10;        LearnerProfileAnnotationDialog(&#10;            studentName = studentName,&#10;            onDismiss = { showAnnotationDialog = false },&#10;            onAddNote = { levelOfProgress, strengthsObserved, strengthsNote, challenges, challengesNote -&gt;&#10;                // TODO: Save annotation data to database or send to analytics&#10;                android.util.Log.d(&quot;LearnModeSession&quot;, &quot; Annotation saved: level=$levelOfProgress, strengths=$strengthsObserved, challenges=$challenges&quot;)&#10;            }&#10;        )&#10;    }&#10;&#10;    // Show loading&#10;    if (isLoading) {&#10;        Box(&#10;            modifier = modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator(color = PurpleColor)&#10;        }&#10;        return&#10;    }&#10;&#10;    val currentWord = words.getOrNull(currentWordIndex)&#10;    val totalWords = words.size.coerceAtLeast(1)&#10;    val currentStep = currentWordIndex + 1&#10;&#10;    // Function to handle skip/next&#10;    fun handleSkipOrNext() {&#10;        if (currentWordIndex &lt; words.size - 1) {&#10;            currentWordIndex++&#10;        } else {&#10;            // Session complete - notify watch and navigate away&#10;            watchConnectionManager.notifyActivityComplete()&#10;            onSessionComplete()&#10;        }&#10;    }&#10;&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 20.dp)&#10;            .padding(top = 40.dp, bottom = 24.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Progress Bar&#10;        ProgressIndicator(&#10;            currentStep = currentStep,&#10;            totalSteps = totalWords,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            activeColor = PurpleColor,&#10;            inactiveColor = LightPurpleColor&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        // Annotate and Skip Button Row&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Annotate button (left) - opens learner profile annotation dialog&#10;            IconButton(onClick = {&#10;                showAnnotationDialog = true&#10;                onAudioClick()&#10;            }) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.ic_annotate),&#10;                    contentDescription = &quot;Annotate&quot;,&#10;                    modifier = Modifier.size(28.dp),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;            }&#10;&#10;            // Skip button (right)&#10;            IconButton(onClick = {&#10;                onSkip()&#10;                handleSkipOrNext()&#10;            }) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.ic_skip),&#10;                    contentDescription = &quot;Skip&quot;,&#10;                    modifier = Modifier.size(28.dp),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        // Title&#10;        Text(&#10;            text = title,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.Black&#10;        )&#10;&#10;        // Activity Type Subtitle (dynamic from database)&#10;        Text(&#10;            text = currentWord?.configurationType ?: &quot;&quot;,&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Medium,&#10;            color = PurpleColor&#10;        )&#10;&#10;        Spacer(Modifier.height(24.dp))&#10;&#10;        // Centered content area (slightly raised)&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Top&#10;        ) {&#10;            Spacer(Modifier.weight(0.3f))&#10;            // Large Content Card with Image (Square) - only show if there's an image&#10;            if (currentWord?.imagePath != null) {&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.85f)&#10;                        .aspectRatio(1f),&#10;                    shape = RoundedCornerShape(24.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFFFBF9FF)&#10;                    ),&#10;                    border = BorderStroke(4.dp, Color(0xFFAE8EFB))&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Image(&#10;                            painter = rememberAsyncImagePainter(&#10;                                ImageRequest.Builder(context)&#10;                                    .data(File(currentWord.imagePath))&#10;                                    .crossfade(true)&#10;                                    .build()&#10;                            ),&#10;                            contentDescription = &quot;Word image&quot;,&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(16.dp),&#10;                            contentScale = ContentScale.Fit&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Extra spacing for cards to push text/dashes lower&#10;                val isNameThePicture = currentWord.configurationType == &quot;Name the Picture&quot;&#10;                val isFillInTheBlanks = currentWord.configurationType == &quot;Fill in the Blank&quot;&#10;                if (isNameThePicture || isFillInTheBlanks) {&#10;                    Spacer(Modifier.height(48.dp))&#10;                } else {&#10;                    Spacer(Modifier.height(24.dp))&#10;                }&#10;            }&#10;&#10;            // Masked Word Display (e.g., &quot;D _ G&quot;) or Full Word Display for &quot;Write the Word&quot; or Blank for &quot;Name the Picture&quot;&#10;            if (currentWord != null) {&#10;                val isWriteTheWord = currentWord.configurationType == &quot;Write the Word&quot;&#10;                val isNameThePicture = currentWord.configurationType == &quot;Name the Picture&quot;&#10;                val isFillInTheBlank = currentWord.configurationType == &quot;Fill in the Blank&quot;&#10;&#10;                when {&#10;                    isWriteTheWord -&gt; {&#10;                        // Write the Word mode - show letters with color based on completion&#10;                        WriteTheWordDisplay(&#10;                            word = currentWord.word,&#10;                            completedIndices = completedLetterIndices,&#10;                            currentIndex = currentLetterIndex,&#10;                            hasImage = currentWord.imagePath != null&#10;                        )&#10;                    }&#10;                    isFillInTheBlank -&gt; {&#10;                        // Fill in the Blank mode - show masked word, reveal correct letter in violet when answered&#10;                        FillInTheBlankDisplay(&#10;                            word = currentWord.word,&#10;                            maskedIndex = currentWord.selectedLetterIndex,&#10;                            isCorrect = fillInBlankCorrect,&#10;                            hasImage = currentWord.imagePath != null&#10;                        )&#10;                    }&#10;                    isNameThePicture -&gt; {&#10;                        // Name the Picture mode - show blanks that reveal letters when correct&#10;                        NameThePictureDisplay(&#10;                            word = currentWord.word,&#10;                            completedIndices = completedLetterIndices,&#10;                            currentIndex = currentLetterIndex,&#10;                            hasImage = currentWord.imagePath != null&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        Text(&#10;                            text = currentWord.getMaskedWord(),&#10;                            fontSize = if (currentWord.imagePath != null) 48.sp else 96.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Black,&#10;                            letterSpacing = if (currentWord.imagePath != null) 4.sp else 8.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(0.7f))&#10;        }&#10;&#10;        Spacer(Modifier.height(24.dp))&#10;    }&#10;}&#10;&#10;/**&#10; * Display for Write the Word mode showing each letter with color based on completion status.&#10; * Current letter has an underline. Completed letters turn purple (#AE8EFB), pending letters are gray.&#10; */&#10;@Composable&#10;private fun WriteTheWordDisplay(&#10;    word: String,&#10;    completedIndices: Set&lt;Int&gt;,&#10;    currentIndex: Int,&#10;    hasImage: Boolean&#10;) {&#10;    val fontSize = if (hasImage) 48.sp else 96.sp&#10;    val letterSpacing = if (hasImage) 12.dp else 16.dp&#10;&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(letterSpacing),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        word.forEachIndexed { index, letter -&gt;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = letter.toString(),&#10;                    fontSize = fontSize,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = when {&#10;                        index in completedIndices -&gt; CompletedLetterColor  // Completed - purple&#10;                        else -&gt; PendingLetterColor  // Pending letters - gray&#10;                    }&#10;                )&#10;&#10;                // Add underline for current letter being input&#10;                if (index == currentIndex) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .width(fontSize.value.dp * 0.7f)&#10;                            .height(4.dp)&#10;                            .background(Color.Black, RoundedCornerShape(2.dp))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Display for Fill in the Blank mode showing the word with a masked letter.&#10; * When the correct letter is written, it's revealed in violet/purple color.&#10; * Uses the same underline style as Write the Word for consistency.&#10; */&#10;@Composable&#10;private fun FillInTheBlankDisplay(&#10;    word: String,&#10;    maskedIndex: Int,&#10;    isCorrect: Boolean,&#10;    hasImage: Boolean&#10;) {&#10;    val fontSize = if (hasImage) 48.sp else 96.sp&#10;    val letterSpacing = if (hasImage) 12.dp else 16.dp&#10;&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(letterSpacing),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        word.forEachIndexed { index, letter -&gt;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = if (index == maskedIndex &amp;&amp; !isCorrect) &quot; &quot; else letter.toString(),&#10;                    fontSize = fontSize,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = when {&#10;                        index == maskedIndex &amp;&amp; isCorrect -&gt; CompletedLetterColor  // Revealed - purple&#10;                        else -&gt; Color.Black  // Other letters - black&#10;                    }&#10;                )&#10;&#10;                // Add underline for the masked letter (current letter being input)&#10;                if (index == maskedIndex &amp;&amp; !isCorrect) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .width(fontSize.value.dp * 0.7f)&#10;                            .height(4.dp)&#10;                            .background(Color.Black, RoundedCornerShape(2.dp))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Display for Name the Picture mode showing blanks initially.&#10; * Completed letters are revealed in purple, pending letters show as underlines.&#10; * Current letter has an underline (same style as Write the Word).&#10; */&#10;@Composable&#10;private fun NameThePictureDisplay(&#10;    word: String,&#10;    completedIndices: Set&lt;Int&gt;,&#10;    currentIndex: Int,&#10;    hasImage: Boolean&#10;) {&#10;    val fontSize = if (hasImage) 48.sp else 96.sp&#10;    val letterSpacing = if (hasImage) 12.dp else 16.dp&#10;&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(letterSpacing),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        word.forEachIndexed { index, letter -&gt;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = if (index in completedIndices) letter.toString() else &quot; &quot;,&#10;                    fontSize = fontSize,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (index in completedIndices) CompletedLetterColor else Color.Transparent&#10;                )&#10;&#10;                // Add underline for letters not yet completed&#10;                if (index !in completedIndices) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .width(fontSize.value.dp * 0.7f)&#10;                            .height(4.dp)&#10;                            .background(Color.Black, RoundedCornerShape(2.dp))&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProgressIndicator(&#10;    currentStep: Int,&#10;    totalSteps: Int,&#10;    modifier: Modifier = Modifier,&#10;    activeColor: Color = PurpleColor,&#10;    inactiveColor: Color = LightPurpleColor&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        repeat(totalSteps) { index -&gt;&#10;            val isActive = index &lt; currentStep&#10;            Box(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .height(8.dp)&#10;                    .clip(RoundedCornerShape(4.dp))&#10;                    .background(&#10;                        if (isActive) activeColor else inactiveColor&#10;                    )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun LearnModeSessionScreenPreview() {&#10;    LearnModeSessionScreen(&#10;        setId = 0L,&#10;        activityTitle = &quot;Vowels&quot;,&#10;        sessionKey = 0&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;private fun ProgressCheckDialog(&#10;    isCorrect: Boolean,&#10;    studentName: String,&#10;    targetLetter: String,&#10;    targetCase: String,&#10;    predictedLetter: String,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    // Extract first name only for more friendly tone&#10;    val firstName = studentName.split(&quot; &quot;).firstOrNull()?.takeIf { it.isNotEmpty() } ?: &quot;&quot;&#10;&#10;    // Define similar shape letters (same as watch side)&#10;    val similarShapeLetters = setOf('C', 'K', 'O', 'P', 'S', 'V', 'W', 'X', 'Z')&#10;&#10;    // Check if there's a case mismatch for similar letters&#10;    val targetUppercase = targetLetter.uppercase()&#10;    val isSimilarShape = targetUppercase.firstOrNull() in similarShapeLetters&#10;    val expectedCase = when (targetCase.lowercase()) {&#10;        &quot;small&quot;, &quot;lowercase&quot; -&gt; targetLetter.lowercase()&#10;        else -&gt; targetLetter.uppercase()&#10;    }&#10;    val hasCaseMismatch = isCorrect &amp;&amp; isSimilarShape &amp;&amp;&#10;                         predictedLetter.isNotEmpty() &amp;&amp;&#10;                         !predictedLetter.equals(expectedCase, ignoreCase = false)&#10;&#10;    Dialog(&#10;        onDismissRequest = onDismiss,&#10;        properties = DialogProperties(usePlatformDefaultWidth = false)&#10;    ) {&#10;        // Full-screen dark overlay&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black.copy(alpha = 0.7f))&#10;                .clickable(&#10;                    indication = null,&#10;                    interactionSource = remember { MutableInteractionSource() }&#10;                ) { onDismiss() },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.85f)&#10;                    .wrapContentHeight(),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                // Mascot Image&#10;                Image(&#10;                    painter = painterResource(&#10;                        id = if (isCorrect) R.drawable.dis_mobile_correct else R.drawable.dis_mobile_incorrect&#10;                    ),&#10;                    contentDescription = if (isCorrect) &quot;Correct&quot; else &quot;Incorrect&quot;,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.7f)&#10;                        .aspectRatio(1f),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;&#10;                Spacer(Modifier.height(24.dp))&#10;&#10;                // Title with first name only&#10;                Text(&#10;                    text = if (isCorrect) {&#10;                        &quot;Great Job${if (firstName.isNotEmpty()) &quot;, $firstName&quot; else &quot;&quot;}!&quot;&#10;                    } else {&#10;                        &quot;Not quite${if (firstName.isNotEmpty()) &quot;, $firstName&quot; else &quot;&quot;}!&quot;&#10;                    },&#10;                    fontSize = 28.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (isCorrect) Color(0xFFCCDB00) else Color(0xFFFF6B6B),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Spacer(Modifier.height(12.dp))&#10;&#10;                // Body text with optional case mismatch disclaimer&#10;                if (isCorrect &amp;&amp; hasCaseMismatch) {&#10;                    Text(&#10;                        text = &quot;You're doing super!\nKeep up the amazing work!&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 24.sp&#10;                    )&#10;&#10;                    Spacer(Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Psst... you wrote ${if (predictedLetter.first().isUpperCase()) &quot;uppercase&quot; else &quot;lowercase&quot;} ${predictedLetter.uppercase()}, &quot; +&#10;                              &quot;but we're practicing ${if (targetCase.lowercase() in listOf(&quot;small&quot;, &quot;lowercase&quot;)) &quot;lowercase&quot; else &quot;uppercase&quot;} letters! &quot; +&#10;                              &quot;They look similar, so that's still great! &quot;,&#10;                        fontSize = 14.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White.copy(alpha = 0.9f),&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 20.sp&#10;                    )&#10;                } else if (isCorrect) {&#10;                    Text(&#10;                        text = &quot;You're doing super!\nKeep up the amazing work!&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 24.sp&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = &quot;Let's give it another go!&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Normal,&#10;                        color = Color.White,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 24.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/TutorialActivityCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/TutorialActivityCard.kt" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.tutorialmode&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.example.app.R&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.material3.MaterialTheme&#10;&#10;/**&#10; * Component for displaying a tutorial activity card with icon and title.&#10; * Uses yellow/orange color scheme with dashed border.&#10; *&#10; * @param title The activity title&#10; * @param iconRes The resource ID of the icon image&#10; * @param isSelected Whether the card is selected&#10; * @param onClick Callback when card is clicked&#10; * @param modifier Optional modifier for the card&#10; */&#10;@Composable&#10;fun TutorialActivityCard(&#10;    title: String,&#10;    iconRes: Int,&#10;    isSelected: Boolean = false,&#10;    onClick: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val yellowColor = Color(0xFFEDBB00)&#10;    val lightYellowColor = Color(0x80EDBB00)&#10;    val greenColor = Color(0xFF4CAF50)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(175.dp)&#10;            .clip(RoundedCornerShape(28.dp))&#10;            .background(if (isSelected) yellowColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .then(&#10;                if (!isSelected) {&#10;                    Modifier.drawBehind {&#10;                        val pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 20f), 0f)&#10;                        drawRoundRect(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 12f, pathEffect = pathEffect),&#10;                            cornerRadius = CornerRadius(28.dp.toPx())&#10;                        )&#10;                    }&#10;                } else {&#10;                    Modifier&#10;                }&#10;            )&#10;            .padding(12.dp)&#10;    ) {&#10;        // Selection circle at top right&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .size(36.dp)&#10;                .clip(CircleShape)&#10;                .background(if (isSelected) Color.White else Color.Transparent)&#10;                .drawBehind {&#10;                    if (!isSelected) {&#10;                        drawCircle(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 4f)&#10;                        )&#10;                    }&#10;                },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = greenColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Icon Circle with Border&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Transparent)&#10;                    .drawBehind {&#10;                        drawCircle(&#10;                            color = if (isSelected) Color(0x40FFFFFF) else lightYellowColor,&#10;                            style = Stroke(width = 16f)&#10;                        )&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(CircleShape)&#10;                        .background(if (isSelected) Color.White else yellowColor),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = title,&#10;                        modifier = Modifier.size(60.dp),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Title&#10;            Text(&#10;                text = title,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Normal,&#10;                color = if (isSelected) Color.White else yellowColor,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Unselected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = false,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Selected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardSelectedPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = true,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/components/tutorial/TutorialActivityCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/components/tutorial/TutorialActivityCard.kt" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.tutorialmode.components.tutorial&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.example.app.R&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.material3.MaterialTheme&#10;&#10;/**&#10; * Component for displaying a tutorial activity card with icon and title.&#10; * Uses yellow/orange color scheme with dashed border.&#10; *&#10; * @param title The activity title&#10; * @param iconRes The resource ID of the icon image&#10; * @param isSelected Whether the card is selected&#10; * @param onClick Callback when card is clicked&#10; * @param modifier Optional modifier for the card&#10; */&#10;@Composable&#10;fun TutorialActivityCard(&#10;    title: String,&#10;    iconRes: Int,&#10;    isSelected: Boolean = false,&#10;    onClick: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val yellowColor = Color(0xFFEDBB00)&#10;    val lightYellowColor = Color(0x80EDBB00)&#10;    val greenColor = Color(0xFF4CAF50)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(175.dp)&#10;            .clip(RoundedCornerShape(28.dp))&#10;            .background(if (isSelected) yellowColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .then(&#10;                if (!isSelected) {&#10;                    Modifier.drawBehind {&#10;                        val pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 20f), 0f)&#10;                        drawRoundRect(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 12f, pathEffect = pathEffect),&#10;                            cornerRadius = CornerRadius(28.dp.toPx())&#10;                        )&#10;                    }&#10;                } else {&#10;                    Modifier&#10;                }&#10;            )&#10;            .padding(12.dp)&#10;    ) {&#10;        // Selection circle at top right&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .size(36.dp)&#10;                .clip(CircleShape)&#10;                .background(if (isSelected) Color.White else Color.Transparent)&#10;                .drawBehind {&#10;                    if (!isSelected) {&#10;                        drawCircle(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 4f)&#10;                        )&#10;                    }&#10;                },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = greenColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Icon Circle with Border&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Transparent)&#10;                    .drawBehind {&#10;                        drawCircle(&#10;                            color = if (isSelected) Color(0x40FFFFFF) else lightYellowColor,&#10;                            style = Stroke(width = 16f)&#10;                        )&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(CircleShape)&#10;                        .background(if (isSelected) Color.White else yellowColor),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = title,&#10;                        modifier = Modifier.size(60.dp),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Title&#10;            Text(&#10;                text = title,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Normal,&#10;                color = if (isSelected) Color.White else yellowColor,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Unselected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = false,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Selected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardSelectedPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = true,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;960&quot;&#10;    android:viewportHeight=&quot;960&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#000000&quot;&#10;        android:pathData=&quot;M420,160h120,-120ZM420,800h120,-120ZM360,880l-54,-182q-48,-38 -77,-95t-29,-123q0,-66 29,-123t77,-95l54,-182h240l54,182q48,38 77,95t29,123q0,66 -29,123t-77,95L600,880L360,880ZM480,680q83,0 141.5,-58.5T680,480q0,-83 -58.5,-141.5T480,320q-83,0 -141.5,58.5T280,480q0,83 58.5,141.5T480,680ZM404,210q20,-5 38.5,-8t37.5,-3q19,0 37.5,3t38.5,8l-16,-50L420,160l-16,50ZM420,800h120l16,-50q-20,5 -38.5,7.5T480,760q-19,0 -37.5,-2.5T404,750l16,50Z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>