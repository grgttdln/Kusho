<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.app&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.kusho&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:common&quot;))&#10;    implementation(libs.core.ktx)&#10;    implementation(libs.lifecycle.runtime.ktx)&#10;    implementation(libs.activity.compose)&#10;    implementation(platform(libs.compose.bom))&#10;    implementation(libs.ui)&#10;    implementation(libs.ui.graphics)&#10;    implementation(libs.ui.tooling.preview)&#10;    implementation(libs.material3)&#10;    implementation(libs.navigation.compose)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.10.2&quot;)&#10;&#10;    // Room Database&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    ksp(libs.room.compiler)&#10;&#10;    // DataStore for session management&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // ViewModel for Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.ext.junit)&#10;    androidTestImplementation(libs.espresso.core)&#10;    androidTestImplementation(platform(libs.compose.bom))&#10;    androidTestImplementation(libs.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.app&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.kusho&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:common&quot;))&#10;    implementation(libs.core.ktx)&#10;    implementation(libs.lifecycle.runtime.ktx)&#10;    implementation(libs.activity.compose)&#10;    implementation(platform(libs.compose.bom))&#10;    implementation(libs.ui)&#10;    implementation(libs.ui.graphics)&#10;    implementation(libs.ui.tooling.preview)&#10;    implementation(libs.material3)&#10;    implementation(libs.navigation.compose)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.10.2&quot;)&#10;&#10;    // Room Database&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    ksp(libs.room.compiler)&#10;&#10;    // DataStore for session management&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // ViewModel for Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1&quot;)&#10;&#10;    // Coil for image loading&#10;    implementation(&quot;io.coil-kt:coil-compose:2.5.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.ext.junit)&#10;    androidTestImplementation(libs.espresso.core)&#10;    androidTestImplementation(platform(libs.compose.bom))&#10;    androidTestImplementation(libs.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/data/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/data/AppDatabase.kt" />
              <option name="originalContent" value="package com.example.app.data&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.example.app.data.dao.UserDao&#10;import com.example.app.data.dao.WordDao&#10;import com.example.app.data.entity.User&#10;import com.example.app.data.entity.Word&#10;&#10;/**&#10; * Room Database for the Kusho application.&#10; *&#10; * This is a singleton database that provides access to the UserDao and WordDao.&#10; * The database is created lazily when first accessed.&#10; */&#10;@Database(&#10;    entities = [User::class, Word::class],&#10;    version = 2,&#10;    exportSchema = false&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    abstract fun userDao(): UserDao&#10;    abstract fun wordDao(): WordDao&#10;&#10;    companion object {&#10;        private const val DATABASE_NAME = &quot;kusho_database&quot;&#10;&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;&#10;        /**&#10;         * Get the singleton instance of the database.&#10;         * Uses double-checked locking for thread safety.&#10;         *&#10;         * @param context Application context&#10;         * @return The singleton AppDatabase instance&#10;         */&#10;        fun getInstance(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: buildDatabase(context).also { INSTANCE = it }&#10;            }&#10;        }&#10;&#10;        private fun buildDatabase(context: Context): AppDatabase {&#10;            return Room.databaseBuilder(&#10;                context.applicationContext,&#10;                AppDatabase::class.java,&#10;                DATABASE_NAME&#10;            )&#10;                // Enable destructive migration for development&#10;                // In production, you should use proper migrations&#10;                .fallbackToDestructiveMigration()&#10;                .build()&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.app.data&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.example.app.data.dao.UserDao&#10;import com.example.app.data.dao.WordDao&#10;import com.example.app.data.entity.User&#10;import com.example.app.data.entity.Word&#10;&#10;/**&#10; * Room Database for the Kusho application.&#10; *&#10; * This is a singleton database that provides access to the UserDao and WordDao.&#10; * The database is created lazily when first accessed.&#10; */&#10;@Database(&#10;    entities = [User::class, Word::class],&#10;    version = 3,&#10;    exportSchema = false&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    abstract fun userDao(): UserDao&#10;    abstract fun wordDao(): WordDao&#10;&#10;    companion object {&#10;        private const val DATABASE_NAME = &quot;kusho_database&quot;&#10;&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;&#10;        /**&#10;         * Get the singleton instance of the database.&#10;         * Uses double-checked locking for thread safety.&#10;         *&#10;         * @param context Application context&#10;         * @return The singleton AppDatabase instance&#10;         */&#10;        fun getInstance(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: buildDatabase(context).also { INSTANCE = it }&#10;            }&#10;        }&#10;&#10;        private fun buildDatabase(context: Context): AppDatabase {&#10;            return Room.databaseBuilder(&#10;                context.applicationContext,&#10;                AppDatabase::class.java,&#10;                DATABASE_NAME&#10;            )&#10;                // Enable destructive migration for development&#10;                // In production, you should use proper migrations&#10;                .fallbackToDestructiveMigration()&#10;                .build()&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/data/entity/Word.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/data/entity/Word.kt" />
              <option name="originalContent" value="package com.example.app.data.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Room Entity representing a word in the user's Word Bank.&#10; *&#10; * Each word is associated with a specific user through the userId foreign key.&#10; * A composite index ensures that the same word cannot be added twice by the same user.&#10; *&#10; * @property id Auto-generated primary key&#10; * @property userId Foreign key reference to the User who owns this word&#10; * @property word The word text stored in the Word Bank&#10; * @property createdAt Timestamp when the word was added&#10; */&#10;@Entity(&#10;    tableName = &quot;words&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = User::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;userId&quot;],&#10;            onDelete = ForeignKey.CASCADE // Delete words when user is deleted&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;userId&quot;]),&#10;        Index(value = [&quot;userId&quot;, &quot;word&quot;], unique = true) // Prevent duplicate words per user&#10;    ]&#10;)&#10;data class Word(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;&#10;    val userId: Long,&#10;&#10;    val word: String,&#10;&#10;    val createdAt: Long = System.currentTimeMillis()&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.app.data.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Room Entity representing a word in the user's Word Bank.&#10; *&#10; * Each word is associated with a specific user through the userId foreign key.&#10; * A composite index ensures that the same word cannot be added twice by the same user.&#10; *&#10; * @property id Auto-generated primary key&#10; * @property userId Foreign key reference to the User who owns this word&#10; * @property word The word text stored in the Word Bank&#10; * @property imagePath Optional file path to an associated image (null if no image)&#10; * @property createdAt Timestamp when the word was added&#10; */&#10;@Entity(&#10;    tableName = &quot;words&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = User::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;userId&quot;],&#10;            onDelete = ForeignKey.CASCADE // Delete words when user is deleted&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;userId&quot;]),&#10;        Index(value = [&quot;userId&quot;, &quot;word&quot;], unique = true) // Prevent duplicate words per user&#10;    ]&#10;)&#10;data class Word(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;&#10;    val userId: Long,&#10;&#10;    val word: String,&#10;&#10;    val imagePath: String? = null,&#10;&#10;    val createdAt: Long = System.currentTimeMillis()&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/data/repository/WordRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/data/repository/WordRepository.kt" />
              <option name="originalContent" value="package com.example.app.data.repository&#10;&#10;import com.example.app.data.dao.WordDao&#10;import com.example.app.data.entity.Word&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withContext&#10;&#10;/**&#10; * Repository for Word data operations.&#10; *&#10; * Provides a clean API for the UI layer to interact with word data.&#10; * All database operations are performed on the IO dispatcher.&#10; */&#10;class WordRepository(private val wordDao: WordDao) {&#10;&#10;    /**&#10;     * Result class for add word operation.&#10;     */&#10;    sealed class AddWordResult {&#10;        data class Success(val wordId: Long) : AddWordResult()&#10;        data class Error(val message: String) : AddWordResult()&#10;    }&#10;&#10;    /**&#10;     * Add a new word to the user's Word Bank.&#10;     *&#10;     * This method:&#10;     * 1. Validates the word is not empty&#10;     * 2. Checks for duplicates (case-insensitive)&#10;     * 3. Inserts the word into the database&#10;     *&#10;     * @param userId The ID of the user adding the word&#10;     * @param word The word to add&#10;     * @return AddWordResult indicating success or failure&#10;     */&#10;    suspend fun addWord(userId: Long, word: String): AddWordResult = withContext(Dispatchers.IO) {&#10;        try {&#10;            val trimmedWord = word.trim()&#10;&#10;            // Validate word is not empty&#10;            if (trimmedWord.isBlank()) {&#10;                return@withContext AddWordResult.Error(&quot;Word cannot be empty&quot;)&#10;            }&#10;&#10;            // Validate word contains only letters&#10;            if (!trimmedWord.all { it.isLetter() }) {&#10;                return@withContext AddWordResult.Error(&quot;Word can only contain letters&quot;)&#10;            }&#10;&#10;            // Check for duplicates (case-insensitive)&#10;            if (wordDao.wordExistsForUser(userId, trimmedWord)) {&#10;                return@withContext AddWordResult.Error(&quot;This word already exists in your Word Bank&quot;)&#10;            }&#10;&#10;            // Insert the word&#10;            val wordEntity = Word(&#10;                userId = userId,&#10;                word = trimmedWord&#10;            )&#10;            val wordId = wordDao.insertWord(wordEntity)&#10;&#10;            AddWordResult.Success(wordId)&#10;        } catch (e: Exception) {&#10;            AddWordResult.Error(e.message ?: &quot;Failed to add word&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all words for a user as a Flow (observable).&#10;     *&#10;     * @param userId The user's ID&#10;     * @return Flow emitting the list of words whenever it changes&#10;     */&#10;    fun getWordsForUser(userId: Long): Flow&lt;List&lt;Word&gt;&gt; {&#10;        return wordDao.getWordsByUserId(userId)&#10;    }&#10;&#10;    /**&#10;     * Get all words for a user (one-shot).&#10;     *&#10;     * @param userId The user's ID&#10;     * @return List of words&#10;     */&#10;    suspend fun getWordsForUserOnce(userId: Long): List&lt;Word&gt; = withContext(Dispatchers.IO) {&#10;        wordDao.getWordsByUserIdOnce(userId)&#10;    }&#10;&#10;    /**&#10;     * Delete a word by its ID.&#10;     *&#10;     * @param wordId The ID of the word to delete&#10;     * @return true if deletion was successful, false otherwise&#10;     */&#10;    suspend fun deleteWord(wordId: Long): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            wordDao.deleteWordById(wordId) &gt; 0&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the word count for a user.&#10;     *&#10;     * @param userId The user's ID&#10;     * @return The number of words in the user's Word Bank&#10;     */&#10;    suspend fun getWordCount(userId: Long): Int = withContext(Dispatchers.IO) {&#10;        wordDao.getWordCountForUser(userId)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.app.data.repository&#10;&#10;import com.example.app.data.dao.WordDao&#10;import com.example.app.data.entity.Word&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withContext&#10;&#10;/**&#10; * Repository for Word data operations.&#10; *&#10; * Provides a clean API for the UI layer to interact with word data.&#10; * All database operations are performed on the IO dispatcher.&#10; */&#10;class WordRepository(private val wordDao: WordDao) {&#10;&#10;    /**&#10;     * Result class for add word operation.&#10;     */&#10;    sealed class AddWordResult {&#10;        data class Success(val wordId: Long) : AddWordResult()&#10;        data class Error(val message: String) : AddWordResult()&#10;    }&#10;&#10;    /**&#10;     * Add a new word to the user's Word Bank.&#10;     *&#10;     * This method:&#10;     * 1. Validates the word is not empty&#10;     * 2. Checks for duplicates (case-insensitive)&#10;     * 3. Inserts the word into the database&#10;     *&#10;     * @param userId The ID of the user adding the word&#10;     * @param word The word to add&#10;     * @param imagePath Optional path to an associated image&#10;     * @return AddWordResult indicating success or failure&#10;     */&#10;    suspend fun addWord(userId: Long, word: String, imagePath: String? = null): AddWordResult = withContext(Dispatchers.IO) {&#10;        try {&#10;            val trimmedWord = word.trim()&#10;&#10;            // Validate word is not empty&#10;            if (trimmedWord.isBlank()) {&#10;                return@withContext AddWordResult.Error(&quot;Word cannot be empty&quot;)&#10;            }&#10;&#10;            // Validate word contains only letters&#10;            if (!trimmedWord.all { it.isLetter() }) {&#10;                return@withContext AddWordResult.Error(&quot;Word can only contain letters&quot;)&#10;            }&#10;&#10;            // Check for duplicates (case-insensitive)&#10;            if (wordDao.wordExistsForUser(userId, trimmedWord)) {&#10;                return@withContext AddWordResult.Error(&quot;This word already exists in your Word Bank&quot;)&#10;            }&#10;&#10;            // Insert the word&#10;            val wordEntity = Word(&#10;                userId = userId,&#10;                word = trimmedWord,&#10;                imagePath = imagePath&#10;            )&#10;            val wordId = wordDao.insertWord(wordEntity)&#10;&#10;            AddWordResult.Success(wordId)&#10;        } catch (e: Exception) {&#10;            AddWordResult.Error(e.message ?: &quot;Failed to add word&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all words for a user as a Flow (observable).&#10;     *&#10;     * @param userId The user's ID&#10;     * @return Flow emitting the list of words whenever it changes&#10;     */&#10;    fun getWordsForUser(userId: Long): Flow&lt;List&lt;Word&gt;&gt; {&#10;        return wordDao.getWordsByUserId(userId)&#10;    }&#10;&#10;    /**&#10;     * Get all words for a user (one-shot).&#10;     *&#10;     * @param userId The user's ID&#10;     * @return List of words&#10;     */&#10;    suspend fun getWordsForUserOnce(userId: Long): List&lt;Word&gt; = withContext(Dispatchers.IO) {&#10;        wordDao.getWordsByUserIdOnce(userId)&#10;    }&#10;&#10;    /**&#10;     * Delete a word by its ID.&#10;     *&#10;     * @param wordId The ID of the word to delete&#10;     * @return true if deletion was successful, false otherwise&#10;     */&#10;    suspend fun deleteWord(wordId: Long): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            wordDao.deleteWordById(wordId) &gt; 0&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the word count for a user.&#10;     *&#10;     * @param userId The user's ID&#10;     * @return The number of words in the user's Word Bank&#10;     */&#10;    suspend fun getWordCount(userId: Long): Int = withContext(Dispatchers.IO) {&#10;        wordDao.getWordCountForUser(userId)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/components/WordBankModal.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/components/WordBankModal.kt" />
              <option name="originalContent" value="package com.example.app.ui.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardCapitalization&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.geometry.Size&#10;&#10;/**&#10; * Reusable Word Bank Modal component.&#10; * Displays a dialog with upload media area, word input, and add button.&#10; *&#10; * @param isVisible Whether the modal is currently visible&#10; * @param wordInput Current text in the word input field&#10; * @param inputError Error message to display, if any&#10; * @param isSubmitEnabled Whether the submit button is enabled&#10; * @param onWordInputChanged Callback when word input changes&#10; * @param onMediaUploadClick Callback when upload media area is clicked&#10; * @param onAddClick Callback when &quot;Add to Word Bank&quot; button is clicked&#10; * @param onDismiss Callback when modal is dismissed&#10; */&#10;@Composable&#10;fun WordBankModal(&#10;    isVisible: Boolean,&#10;    wordInput: String,&#10;    inputError: String?,&#10;    isSubmitEnabled: Boolean,&#10;    onWordInputChanged: (String) -&gt; Unit,&#10;    onMediaUploadClick: () -&gt; Unit,&#10;    onAddClick: () -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    if (!isVisible) return&#10;&#10;    val focusManager = LocalFocusManager.current&#10;&#10;    Dialog(&#10;        onDismissRequest = onDismiss,&#10;        properties = DialogProperties(&#10;            dismissOnBackPress = true,&#10;            dismissOnClickOutside = true,&#10;            usePlatformDefaultWidth = false&#10;        )&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .wrapContentHeight()&#10;                .clip(RoundedCornerShape(24.dp))&#10;                .background(Color.White)&#10;                .padding(32.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Upload Media Area&#10;                UploadMediaArea(&#10;                    onClick = onMediaUploadClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(160.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Word Label&#10;                Text(&#10;                    text = &quot;Word&quot;,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = Color(0xFF0B0B0B),&#10;                    modifier = Modifier.align(Alignment.Start)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Word Input Field&#10;                OutlinedTextField(&#10;                    value = wordInput,&#10;                    onValueChange = onWordInputChanged,&#10;                    placeholder = {&#10;                        Text(&#10;                            text = &quot;E.g, dog&quot;,&#10;                            color = Color.Gray&#10;                        )&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF49A9FF),&#10;                        unfocusedBorderColor = Color(0xFFE0E0E0),&#10;                        errorBorderColor = Color.Red,&#10;                        focusedContainerColor = Color.White,&#10;                        unfocusedContainerColor = Color.White,&#10;                        cursorColor = Color(0xFF49A9FF)&#10;                    ),&#10;                    singleLine = true,&#10;                    isError = inputError != null,&#10;                    supportingText = if (inputError != null) {&#10;                        { Text(text = inputError, color = Color.Red) }&#10;                    } else null,&#10;                    keyboardOptions = KeyboardOptions(&#10;                        capitalization = KeyboardCapitalization.Words,&#10;                        imeAction = ImeAction.Done&#10;                    ),&#10;                    keyboardActions = KeyboardActions(&#10;                        onDone = {&#10;                            focusManager.clearFocus()&#10;                            if (isSubmitEnabled) {&#10;                                onAddClick()&#10;                            }&#10;                        }&#10;                    )&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Add to Word Bank Button&#10;                Button(&#10;                    onClick = {&#10;                        focusManager.clearFocus()&#10;                        onAddClick()&#10;                    },&#10;                    enabled = isSubmitEnabled,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    shape = RoundedCornerShape(18.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF49A9FF),&#10;                        disabledContainerColor = Color(0xFFB0D9FF)&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Add to Word Bank&quot;,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Upload Media Area component with dashed border.&#10; */&#10;@Composable&#10;fun UploadMediaArea(&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val dashColor = Color(0xFF49A9FF)&#10;    val backgroundColor = Color(0xFFE8F4FD)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .clip(RoundedCornerShape(16.dp))&#10;            .background(backgroundColor)&#10;            .clickable { onClick() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Draw dashed border&#10;        Canvas(modifier = Modifier.matchParentSize()) {&#10;            val strokeWidth = 2.dp.toPx()&#10;            val dashLength = 10.dp.toPx()&#10;            val gapLength = 6.dp.toPx()&#10;&#10;            drawRoundRect(&#10;                color = dashColor,&#10;                size = Size(size.width, size.height),&#10;                cornerRadius = CornerRadius(16.dp.toPx()),&#10;                style = Stroke(&#10;                    width = strokeWidth,&#10;                    pathEffect = PathEffect.dashPathEffect(&#10;                        floatArrayOf(dashLength, gapLength),&#10;                        0f&#10;                    )&#10;                )&#10;            )&#10;        }&#10;&#10;        // Content&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            // Plus icon in circle&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .border(&#10;                        width = 2.dp,&#10;                        color = Color(0xFF49A9FF),&#10;                        shape = CircleShape&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Add,&#10;                    contentDescription = &quot;Add media&quot;,&#10;                    tint = Color(0xFF49A9FF),&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = &quot;Upload\nMedia&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                color = Color(0xFF49A9FF),&#10;                textAlign = TextAlign.Center,&#10;                lineHeight = 18.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun WordBankModalPreview() {&#10;    WordBankModal(&#10;        isVisible = true,&#10;        wordInput = &quot;&quot;,&#10;        inputError = null,&#10;        isSubmitEnabled = false,&#10;        onWordInputChanged = {},&#10;        onMediaUploadClick = {},&#10;        onAddClick = {},&#10;        onDismiss = {}&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun WordBankModalWithInputPreview() {&#10;    WordBankModal(&#10;        isVisible = true,&#10;        wordInput = &quot;dog&quot;,&#10;        inputError = null,&#10;        isSubmitEnabled = true,&#10;        onWordInputChanged = {},&#10;        onMediaUploadClick = {},&#10;        onAddClick = {},&#10;        onDismiss = {}&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun UploadMediaAreaPreview() {&#10;    UploadMediaArea(&#10;        onClick = {},&#10;        modifier = Modifier&#10;            .width(300.dp)&#10;            .height(160.dp)&#10;            .padding(16.dp)&#10;    )&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.app.ui.components&#10;&#10;import android.net.Uri&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardCapitalization&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.geometry.Size&#10;import coil.compose.AsyncImage&#10;&#10;/**&#10; * Reusable Word Bank Modal component.&#10; * Displays a dialog with upload media area, word input, and add button.&#10; *&#10; * @param isVisible Whether the modal is currently visible&#10; * @param wordInput Current text in the word input field&#10; * @param selectedImageUri URI of the selected image (optional)&#10; * @param inputError Error message to display, if any&#10; * @param imageError Error message for image upload, if any&#10; * @param isSubmitEnabled Whether the submit button is enabled&#10; * @param isLoading Whether the modal is in a loading state&#10; * @param onWordInputChanged Callback when word input changes&#10; * @param onMediaUploadClick Callback when upload media area is clicked&#10; * @param onRemoveImage Callback when remove image button is clicked&#10; * @param onAddClick Callback when &quot;Add to Word Bank&quot; button is clicked&#10; * @param onDismiss Callback when modal is dismissed&#10; */&#10;@Composable&#10;fun WordBankModal(&#10;    isVisible: Boolean,&#10;    wordInput: String,&#10;    selectedImageUri: Uri?,&#10;    inputError: String?,&#10;    imageError: String?,&#10;    isSubmitEnabled: Boolean,&#10;    isLoading: Boolean,&#10;    onWordInputChanged: (String) -&gt; Unit,&#10;    onMediaUploadClick: () -&gt; Unit,&#10;    onRemoveImage: () -&gt; Unit,&#10;    onAddClick: () -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    if (!isVisible) return&#10;&#10;    val focusManager = LocalFocusManager.current&#10;&#10;    Dialog(&#10;        onDismissRequest = { if (!isLoading) onDismiss() },&#10;        properties = DialogProperties(&#10;            dismissOnBackPress = !isLoading,&#10;            dismissOnClickOutside = !isLoading,&#10;            usePlatformDefaultWidth = false&#10;        )&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.9f)&#10;                .wrapContentHeight()&#10;                .clip(RoundedCornerShape(24.dp))&#10;                .background(Color.White)&#10;                .padding(32.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Upload Media Area or Selected Image Preview&#10;                if (selectedImageUri != null) {&#10;                    SelectedImagePreview(&#10;                        imageUri = selectedImageUri,&#10;                        onRemoveClick = onRemoveImage,&#10;                        enabled = !isLoading,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(160.dp)&#10;                    )&#10;                } else {&#10;                    UploadMediaArea(&#10;                        onClick = onMediaUploadClick,&#10;                        enabled = !isLoading,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(160.dp)&#10;                    )&#10;                }&#10;&#10;                // Image error message&#10;                if (imageError != null) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = imageError,&#10;                        fontSize = 12.sp,&#10;                        color = Color.Red,&#10;                        modifier = Modifier.align(Alignment.Start)&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Word Label&#10;                Text(&#10;                    text = &quot;Word&quot;,&#10;                    fontSize = 16.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = Color(0xFF0B0B0B),&#10;                    modifier = Modifier.align(Alignment.Start)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Word Input Field&#10;                OutlinedTextField(&#10;                    value = wordInput,&#10;                    onValueChange = onWordInputChanged,&#10;                    placeholder = {&#10;                        Text(&#10;                            text = &quot;E.g, dog&quot;,&#10;                            color = Color.Gray&#10;                        )&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF49A9FF),&#10;                        unfocusedBorderColor = Color(0xFFE0E0E0),&#10;                        errorBorderColor = Color.Red,&#10;                        focusedContainerColor = Color.White,&#10;                        unfocusedContainerColor = Color.White,&#10;                        cursorColor = Color(0xFF49A9FF),&#10;                        disabledBorderColor = Color(0xFFE0E0E0),&#10;                        disabledContainerColor = Color(0xFFF5F5F5)&#10;                    ),&#10;                    singleLine = true,&#10;                    isError = inputError != null,&#10;                    enabled = !isLoading,&#10;                    supportingText = if (inputError != null) {&#10;                        { Text(text = inputError, color = Color.Red) }&#10;                    } else null,&#10;                    keyboardOptions = KeyboardOptions(&#10;                        capitalization = KeyboardCapitalization.Words,&#10;                        imeAction = ImeAction.Done&#10;                    ),&#10;                    keyboardActions = KeyboardActions(&#10;                        onDone = {&#10;                            focusManager.clearFocus()&#10;                            if (isSubmitEnabled &amp;&amp; !isLoading) {&#10;                                onAddClick()&#10;                            }&#10;                        }&#10;                    )&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Add to Word Bank Button&#10;                Button(&#10;                    onClick = {&#10;                        focusManager.clearFocus()&#10;                        onAddClick()&#10;                    },&#10;                    enabled = isSubmitEnabled &amp;&amp; !isLoading,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(56.dp),&#10;                    shape = RoundedCornerShape(18.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF49A9FF),&#10;                        disabledContainerColor = Color(0xFFB0D9FF)&#10;                    )&#10;                ) {&#10;                    if (isLoading) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(24.dp),&#10;                            color = Color.White,&#10;                            strokeWidth = 2.dp&#10;                        )&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Add to Word Bank&quot;,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = Color.White&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Selected Image Preview component showing the selected image with a remove button.&#10; */&#10;@Composable&#10;fun SelectedImagePreview(&#10;    imageUri: Uri,&#10;    onRemoveClick: () -&gt; Unit,&#10;    enabled: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .clip(RoundedCornerShape(16.dp))&#10;            .background(Color(0xFFE8F4FD))&#10;    ) {&#10;        // Image&#10;        AsyncImage(&#10;            model = imageUri,&#10;            contentDescription = &quot;Selected image&quot;,&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .clip(RoundedCornerShape(16.dp)),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        // Remove button&#10;        if (enabled) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(8.dp)&#10;                    .size(32.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Black.copy(alpha = 0.6f))&#10;                    .clickable { onRemoveClick() },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Remove image&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(18.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Upload Media Area component with dashed border.&#10; */&#10;@Composable&#10;fun UploadMediaArea(&#10;    onClick: () -&gt; Unit,&#10;    enabled: Boolean = true,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val dashColor = if (enabled) Color(0xFF49A9FF) else Color(0xFFB0D9FF)&#10;    val backgroundColor = Color(0xFFE8F4FD)&#10;    val contentColor = if (enabled) Color(0xFF49A9FF) else Color(0xFFB0D9FF)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .clip(RoundedCornerShape(16.dp))&#10;            .background(backgroundColor)&#10;            .then(&#10;                if (enabled) Modifier.clickable { onClick() } else Modifier&#10;            ),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Draw dashed border&#10;        Canvas(modifier = Modifier.matchParentSize()) {&#10;            val strokeWidth = 2.dp.toPx()&#10;            val dashLength = 10.dp.toPx()&#10;            val gapLength = 6.dp.toPx()&#10;&#10;            drawRoundRect(&#10;                color = dashColor,&#10;                size = Size(size.width, size.height),&#10;                cornerRadius = CornerRadius(16.dp.toPx()),&#10;                style = Stroke(&#10;                    width = strokeWidth,&#10;                    pathEffect = PathEffect.dashPathEffect(&#10;                        floatArrayOf(dashLength, gapLength),&#10;                        0f&#10;                    )&#10;                )&#10;            )&#10;        }&#10;&#10;        // Content&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            // Plus icon in circle&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .border(&#10;                        width = 2.dp,&#10;                        color = contentColor,&#10;                        shape = CircleShape&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Add,&#10;                    contentDescription = &quot;Add media&quot;,&#10;                    tint = contentColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = &quot;Upload\nMedia&quot;,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                color = contentColor,&#10;                textAlign = TextAlign.Center,&#10;                lineHeight = 18.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun WordBankModalPreview() {&#10;    WordBankModal(&#10;        isVisible = true,&#10;        wordInput = &quot;&quot;,&#10;        selectedImageUri = null,&#10;        inputError = null,&#10;        imageError = null,&#10;        isSubmitEnabled = false,&#10;        isLoading = false,&#10;        onWordInputChanged = {},&#10;        onMediaUploadClick = {},&#10;        onRemoveImage = {},&#10;        onAddClick = {},&#10;        onDismiss = {}&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun WordBankModalWithInputPreview() {&#10;    WordBankModal(&#10;        isVisible = true,&#10;        wordInput = &quot;dog&quot;,&#10;        selectedImageUri = null,&#10;        inputError = null,&#10;        imageError = null,&#10;        isSubmitEnabled = true,&#10;        isLoading = false,&#10;        onWordInputChanged = {},&#10;        onMediaUploadClick = {},&#10;        onRemoveImage = {},&#10;        onAddClick = {},&#10;        onDismiss = {}&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun UploadMediaAreaPreview() {&#10;    UploadMediaArea(&#10;        onClick = {},&#10;        modifier = Modifier&#10;            .width(300.dp)&#10;            .height(160.dp)&#10;            .padding(16.dp)&#10;    )&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/LessonScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/LessonScreen.kt" />
              <option name="originalContent" value="package com.example.app.ui.feature.learn&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.app.R&#10;import com.example.app.data.entity.Word&#10;import com.example.app.ui.components.BottomNavBar&#10;import com.example.app.ui.components.WordBankModal&#10;&#10;@Composable&#10;fun LessonScreen(&#10;    onNavigate: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: LessonViewModel = viewModel()&#10;) {&#10;    // Collect UI state from ViewModel&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    Box(&#10;        modifier = modifier.fillMaxSize()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(horizontal = 20.dp)&#10;                .padding(bottom = 80.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Fixed Header Section&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 20.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Spacer(Modifier.height(24.dp))&#10;&#10;            Image(&#10;                painter = painterResource(id = R.drawable.ic_kusho),&#10;                contentDescription = &quot;Kusho Logo&quot;,&#10;                modifier = Modifier&#10;                    .height(54.dp)&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 30.dp)&#10;                    .offset(x = 10.dp),&#10;                contentScale = ContentScale.Fit,&#10;                alignment = Alignment.Center&#10;            )&#10;&#10;                Spacer(Modifier.height(32.dp))&#10;&#10;                Text(&#10;                    text = &quot;Customize Activities&quot;,&#10;                    fontSize = 28.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF0B0B0B)&#10;                )&#10;&#10;                Spacer(Modifier.height(28.dp))&#10;&#10;                // Activity Cards Row - Fixed&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    ActivityCard(&#10;                        title = &quot;Your\nActivities&quot;,&#10;                        imageRes = R.drawable.ic_book,&#10;                        backgroundColor = Color(0xFF5DB7FF),&#10;                        onClick = { },&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;&#10;                    ActivityCard(&#10;                        title = &quot;Your\nSets&quot;,&#10;                        imageRes = R.drawable.ic_pen,&#10;                        backgroundColor = Color(0xFF5DB7FF),&#10;                        onClick = { },&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                }&#10;&#10;                Spacer(Modifier.height(32.dp))&#10;&#10;                // Word Bank Title&#10;                Text(&#10;                    text = &quot;Word Bank&quot;,&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF0B0B0B),&#10;                    modifier = Modifier.align(Alignment.Start)&#10;                )&#10;&#10;                Spacer(Modifier.height(16.dp))&#10;            }&#10;&#10;            // Scrollable Word Bank List - Only this section scrolls&#10;            Box(&#10;                modifier = Modifier&#10;                    .weight(1f) // Takes remaining space&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 20.dp)&#10;            ) {&#10;                WordBankList(&#10;                    words = uiState.words,&#10;                    onWordClick = { word -&gt;&#10;                        viewModel.onWordClick(word)&#10;                    },&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;&#10;            // Fixed &quot;+ Word Bank&quot; Button above bottom nav&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            AddWordBankButton(&#10;                onClick = {&#10;                    viewModel.showWordBankModal()&#10;                },&#10;                modifier = Modifier.padding(horizontal = 20.dp)&#10;            )&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;        }&#10;&#10;        // Bottom Navigation Bar - Fixed at bottom&#10;        BottomNavBar(&#10;            selectedTab = 3,&#10;            onTabSelected = { onNavigate(it) },&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;&#10;        // Word Bank Modal&#10;        WordBankModal(&#10;            isVisible = uiState.isModalVisible,&#10;            wordInput = uiState.wordInput,&#10;            inputError = uiState.inputError,&#10;            isSubmitEnabled = viewModel.isSubmitEnabled(),&#10;            onWordInputChanged = { viewModel.onWordInputChanged(it) },&#10;            onMediaUploadClick = {&#10;                // TODO: Implement media picker&#10;            },&#10;            onAddClick = {&#10;                viewModel.addWordToBank()&#10;            },&#10;            onDismiss = {&#10;                viewModel.hideWordBankModal()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Reusable Word Bank List component with scrollable grid layout.&#10; * Only this component scrolls, keeping the rest of the UI fixed.&#10; */&#10;@Composable&#10;fun WordBankList(&#10;    words: List&lt;Word&gt;,&#10;    onWordClick: (Word) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(2),&#10;        modifier = modifier,&#10;        horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp),&#10;        contentPadding = PaddingValues(bottom = 8.dp)&#10;    ) {&#10;        items(words, key = { it.id }) { word -&gt;&#10;            WordBankItem(&#10;                word = word.word,&#10;                onClick = { onWordClick(word) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Individual word item in the Word Bank grid.&#10; */&#10;@Composable&#10;fun WordBankItem(&#10;    word: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(48.dp)&#10;            .clip(RoundedCornerShape(14.dp))&#10;            .border(&#10;                width = 1.dp,&#10;                color = Color(0xFF49A9FF),&#10;                shape = RoundedCornerShape(14.dp)&#10;            )&#10;            .clickable { onClick() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = word,&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.Medium,&#10;            color = Color(0xFF49A9FF),&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Add Word Bank button component.&#10; */&#10;@Composable&#10;fun AddWordBankButton(&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = modifier&#10;            .height(60.dp)&#10;            .widthIn(min = 200.dp),&#10;        shape = RoundedCornerShape(18.dp),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = Color(0xFF49A9FF)&#10;        ),&#10;        contentPadding = PaddingValues(horizontal = 32.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Add,&#10;            contentDescription = null,&#10;            tint = Color.White,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;        Spacer(Modifier.width(8.dp))&#10;        Text(&#10;            text = &quot;Word Bank&quot;,&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.SemiBold,&#10;            color = Color.White&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ActivityCard(&#10;    title: String,&#10;    imageRes: Int,&#10;    backgroundColor: Color,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .clip(RoundedCornerShape(24.dp))&#10;            .background(backgroundColor)&#10;            .clickable { onClick() }&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Image(&#10;                painter = painterResource(id = imageRes),&#10;                contentDescription = title,&#10;                modifier = Modifier&#10;                    .size(40.dp)&#10;                    .align(Alignment.Start),&#10;                contentScale = ContentScale.Fit&#10;            )&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Bottom&#10;            ) {&#10;                Text(&#10;                    text = title,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.White,&#10;                    lineHeight = 22.sp,&#10;                    modifier = Modifier.weight(1f, fill = false)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(36.dp)&#10;                        .background(Color.White, RoundedCornerShape(50)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                        contentDescription = &quot;Navigate&quot;,&#10;                        tint = backgroundColor,&#10;                        modifier = Modifier.size(18.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, showSystemUi = true)&#10;@Composable&#10;fun LessonScreenPreview() {&#10;    LessonScreen(onNavigate = {})&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn&#10;&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.PickVisualMediaRequest&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.app.R&#10;import com.example.app.data.entity.Word&#10;import com.example.app.ui.components.BottomNavBar&#10;import com.example.app.ui.components.WordBankModal&#10;&#10;@Composable&#10;fun LessonScreen(&#10;    onNavigate: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: LessonViewModel = viewModel()&#10;) {&#10;    // Collect UI state from ViewModel&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Image picker launcher&#10;    val imagePickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.PickVisualMedia()&#10;    ) { uri -&gt;&#10;        viewModel.onMediaSelected(uri)&#10;    }&#10;&#10;    Box(&#10;        modifier = modifier.fillMaxSize()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(horizontal = 20.dp)&#10;                .padding(bottom = 80.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Fixed Header Section&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 20.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Spacer(Modifier.height(24.dp))&#10;&#10;            Image(&#10;                painter = painterResource(id = R.drawable.ic_kusho),&#10;                contentDescription = &quot;Kusho Logo&quot;,&#10;                modifier = Modifier&#10;                    .height(54.dp)&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 30.dp)&#10;                    .offset(x = 10.dp),&#10;                contentScale = ContentScale.Fit,&#10;                alignment = Alignment.Center&#10;            )&#10;&#10;                Spacer(Modifier.height(32.dp))&#10;&#10;                Text(&#10;                    text = &quot;Customize Activities&quot;,&#10;                    fontSize = 28.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF0B0B0B)&#10;                )&#10;&#10;                Spacer(Modifier.height(28.dp))&#10;&#10;                // Activity Cards Row - Fixed&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    ActivityCard(&#10;                        title = &quot;Your\nActivities&quot;,&#10;                        imageRes = R.drawable.ic_book,&#10;                        backgroundColor = Color(0xFF5DB7FF),&#10;                        onClick = { },&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;&#10;                    ActivityCard(&#10;                        title = &quot;Your\nSets&quot;,&#10;                        imageRes = R.drawable.ic_pen,&#10;                        backgroundColor = Color(0xFF5DB7FF),&#10;                        onClick = { },&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                }&#10;&#10;                Spacer(Modifier.height(32.dp))&#10;&#10;                // Word Bank Title&#10;                Text(&#10;                    text = &quot;Word Bank&quot;,&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF0B0B0B),&#10;                    modifier = Modifier.align(Alignment.Start)&#10;                )&#10;&#10;                Spacer(Modifier.height(16.dp))&#10;            }&#10;&#10;            // Scrollable Word Bank List - Only this section scrolls&#10;            Box(&#10;                modifier = Modifier&#10;                    .weight(1f) // Takes remaining space&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 20.dp)&#10;            ) {&#10;                WordBankList(&#10;                    words = uiState.words,&#10;                    onWordClick = { word -&gt;&#10;                        viewModel.onWordClick(word)&#10;                    },&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;&#10;            // Fixed &quot;+ Word Bank&quot; Button above bottom nav&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            AddWordBankButton(&#10;                onClick = {&#10;                    viewModel.showWordBankModal()&#10;                },&#10;                modifier = Modifier.padding(horizontal = 20.dp)&#10;            )&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;        }&#10;&#10;        // Bottom Navigation Bar - Fixed at bottom&#10;        BottomNavBar(&#10;            selectedTab = 3,&#10;            onTabSelected = { onNavigate(it) },&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;&#10;        // Word Bank Modal&#10;        WordBankModal(&#10;            isVisible = uiState.isModalVisible,&#10;            wordInput = uiState.wordInput,&#10;            selectedImageUri = uiState.selectedMediaUri,&#10;            inputError = uiState.inputError,&#10;            imageError = uiState.imageError,&#10;            isSubmitEnabled = viewModel.isSubmitEnabled(),&#10;            isLoading = uiState.isLoading,&#10;            onWordInputChanged = { viewModel.onWordInputChanged(it) },&#10;            onMediaUploadClick = {&#10;                imagePickerLauncher.launch(&#10;                    PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)&#10;                )&#10;            },&#10;            onRemoveImage = {&#10;                viewModel.onRemoveMedia()&#10;            },&#10;            onAddClick = {&#10;                viewModel.addWordToBank()&#10;            },&#10;            onDismiss = {&#10;                viewModel.hideWordBankModal()&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Reusable Word Bank List component with scrollable grid layout.&#10; * Only this component scrolls, keeping the rest of the UI fixed.&#10; */&#10;@Composable&#10;fun WordBankList(&#10;    words: List&lt;Word&gt;,&#10;    onWordClick: (Word) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(2),&#10;        modifier = modifier,&#10;        horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp),&#10;        contentPadding = PaddingValues(bottom = 8.dp)&#10;    ) {&#10;        items(words, key = { it.id }) { word -&gt;&#10;            WordBankItem(&#10;                word = word.word,&#10;                onClick = { onWordClick(word) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Individual word item in the Word Bank grid.&#10; */&#10;@Composable&#10;fun WordBankItem(&#10;    word: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(48.dp)&#10;            .clip(RoundedCornerShape(14.dp))&#10;            .border(&#10;                width = 1.dp,&#10;                color = Color(0xFF49A9FF),&#10;                shape = RoundedCornerShape(14.dp)&#10;            )&#10;            .clickable { onClick() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = word,&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.Medium,&#10;            color = Color(0xFF49A9FF),&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Add Word Bank button component.&#10; */&#10;@Composable&#10;fun AddWordBankButton(&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = modifier&#10;            .height(60.dp)&#10;            .widthIn(min = 200.dp),&#10;        shape = RoundedCornerShape(18.dp),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = Color(0xFF49A9FF)&#10;        ),&#10;        contentPadding = PaddingValues(horizontal = 32.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Add,&#10;            contentDescription = null,&#10;            tint = Color.White,&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;        Spacer(Modifier.width(8.dp))&#10;        Text(&#10;            text = &quot;Word Bank&quot;,&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.SemiBold,&#10;            color = Color.White&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ActivityCard(&#10;    title: String,&#10;    imageRes: Int,&#10;    backgroundColor: Color,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .clip(RoundedCornerShape(24.dp))&#10;            .background(backgroundColor)&#10;            .clickable { onClick() }&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            verticalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Image(&#10;                painter = painterResource(id = imageRes),&#10;                contentDescription = title,&#10;                modifier = Modifier&#10;                    .size(40.dp)&#10;                    .align(Alignment.Start),&#10;                contentScale = ContentScale.Fit&#10;            )&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.Bottom&#10;            ) {&#10;                Text(&#10;                    text = title,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.White,&#10;                    lineHeight = 22.sp,&#10;                    modifier = Modifier.weight(1f, fill = false)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(36.dp)&#10;                        .background(Color.White, RoundedCornerShape(50)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                        contentDescription = &quot;Navigate&quot;,&#10;                        tint = backgroundColor,&#10;                        modifier = Modifier.size(18.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, showSystemUi = true)&#10;@Composable&#10;fun LessonScreenPreview() {&#10;    LessonScreen(onNavigate = {})&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/LessonViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/LessonViewModel.kt" />
              <option name="originalContent" value="package com.example.app.ui.feature.learn&#10;&#10;import android.app.Application&#10;import android.net.Uri&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.app.data.AppDatabase&#10;import com.example.app.data.SessionManager&#10;import com.example.app.data.entity.Word&#10;import com.example.app.data.repository.WordRepository&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.filterNotNull&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * ViewModel for the Lesson Screen managing Word Bank state and modal interactions.&#10; *&#10; * Uses AndroidViewModel to access the application context for database and session management.&#10; * Words are persisted to Room database and associated with the current user.&#10; */&#10;class LessonViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    // Initialize database and repositories&#10;    private val database = AppDatabase.getInstance(application)&#10;    private val wordRepository = WordRepository(database.wordDao())&#10;    private val sessionManager = SessionManager.getInstance(application)&#10;&#10;    private val _uiState = MutableStateFlow(LessonUiState())&#10;    val uiState: StateFlow&lt;LessonUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Current user ID (null if not logged in)&#10;    private var currentUserId: Long? = null&#10;&#10;    init {&#10;        // Observe the current user session&#10;        viewModelScope.launch {&#10;            sessionManager.currentUser.collectLatest { user -&gt;&#10;                currentUserId = user?.id&#10;                if (user != null) {&#10;                    loadWordsForUser(user.id)&#10;                } else {&#10;                    // Clear words if no user is logged in&#10;                    _uiState.update { it.copy(words = emptyList()) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load words for the current user from the database.&#10;     */&#10;    private fun loadWordsForUser(userId: Long) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            wordRepository.getWordsForUser(userId).collectLatest { words -&gt;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        words = words,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Show the Word Bank modal.&#10;     */&#10;    fun showWordBankModal() {&#10;        _uiState.update { it.copy(isModalVisible = true) }&#10;    }&#10;&#10;    /**&#10;     * Hide the Word Bank modal and reset input state.&#10;     */&#10;    fun hideWordBankModal() {&#10;        _uiState.update {&#10;            it.copy(&#10;                isModalVisible = false,&#10;                wordInput = &quot;&quot;,&#10;                selectedMediaUri = null,&#10;                inputError = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update the word input text.&#10;     */&#10;    fun onWordInputChanged(word: String) {&#10;        _uiState.update {&#10;            it.copy(&#10;                wordInput = word.trim(),&#10;                inputError = null // Clear error when user types&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update the selected media URI.&#10;     */&#10;    fun onMediaSelected(uri: Uri?) {&#10;        _uiState.update { it.copy(selectedMediaUri = uri) }&#10;    }&#10;&#10;    /**&#10;     * Validate and add the word to the Word Bank.&#10;     * Saves to Room database associated with the current user.&#10;     */&#10;    fun addWordToBank() {&#10;        val userId = currentUserId&#10;        if (userId == null) {&#10;            _uiState.update { it.copy(inputError = &quot;Please log in to add words&quot;) }&#10;            return&#10;        }&#10;&#10;        val currentWord = _uiState.value.wordInput.trim()&#10;&#10;        // Basic validation before database operation&#10;        if (!isValidWord(currentWord)) {&#10;            _uiState.update { it.copy(inputError = &quot;Please enter a valid word&quot;) }&#10;            return&#10;        }&#10;&#10;        // Set loading state&#10;        _uiState.update { it.copy(isLoading = true) }&#10;&#10;        // Add word to database on background thread&#10;        viewModelScope.launch {&#10;            when (val result = wordRepository.addWord(userId, currentWord)) {&#10;                is WordRepository.AddWordResult.Success -&gt; {&#10;                    // Success - close modal and reset input&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            isModalVisible = false,&#10;                            wordInput = &quot;&quot;,&#10;                            selectedMediaUri = null,&#10;                            inputError = null,&#10;                            isLoading = false&#10;                        )&#10;                    }&#10;                }&#10;                is WordRepository.AddWordResult.Error -&gt; {&#10;                    // Show error message&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            inputError = result.message,&#10;                            isLoading = false&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete a word from the Word Bank.&#10;     */&#10;    fun deleteWord(wordId: Long) {&#10;        viewModelScope.launch {&#10;            wordRepository.deleteWord(wordId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle word item click.&#10;     */&#10;    fun onWordClick(word: Word) {&#10;        // Can be extended for word selection, editing, etc.&#10;    }&#10;&#10;    /**&#10;     * Validate if the word is valid.&#10;     * A valid word is non-empty and contains only letters.&#10;     */&#10;    private fun isValidWord(word: String): Boolean {&#10;        return word.isNotBlank() &amp;&amp; word.all { it.isLetter() }&#10;    }&#10;&#10;    /**&#10;     * Check if the current input is valid for submission.&#10;     */&#10;    fun isSubmitEnabled(): Boolean {&#10;        val word = _uiState.value.wordInput.trim()&#10;        return word.isNotBlank() &amp;&amp; word.all { it.isLetter() } &amp;&amp; !_uiState.value.isLoading&#10;    }&#10;}&#10;&#10;/**&#10; * UI State for the Lesson Screen.&#10; */&#10;data class LessonUiState(&#10;    val words: List&lt;Word&gt; = emptyList(),&#10;    val isModalVisible: Boolean = false,&#10;    val wordInput: String = &quot;&quot;,&#10;    val selectedMediaUri: Uri? = null,&#10;    val inputError: String? = null,&#10;    val isLoading: Boolean = false&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn&#10;&#10;import android.app.Application&#10;import android.net.Uri&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.app.data.AppDatabase&#10;import com.example.app.data.SessionManager&#10;import com.example.app.data.entity.Word&#10;import com.example.app.data.repository.WordRepository&#10;import com.example.app.util.ImageStorageManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * ViewModel for the Lesson Screen managing Word Bank state and modal interactions.&#10; *&#10; * Uses AndroidViewModel to access the application context for database and session management.&#10; * Words are persisted to Room database and associated with the current user.&#10; */&#10;class LessonViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    // Initialize database and repositories&#10;    private val database = AppDatabase.getInstance(application)&#10;    private val wordRepository = WordRepository(database.wordDao())&#10;    private val sessionManager = SessionManager.getInstance(application)&#10;    private val imageStorageManager = ImageStorageManager(application)&#10;&#10;    private val _uiState = MutableStateFlow(LessonUiState())&#10;    val uiState: StateFlow&lt;LessonUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Current user ID (null if not logged in)&#10;    private var currentUserId: Long? = null&#10;&#10;    init {&#10;        // Observe the current user session&#10;        viewModelScope.launch {&#10;            sessionManager.currentUser.collectLatest { user -&gt;&#10;                currentUserId = user?.id&#10;                if (user != null) {&#10;                    loadWordsForUser(user.id)&#10;                } else {&#10;                    // Clear words if no user is logged in&#10;                    _uiState.update { it.copy(words = emptyList()) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load words for the current user from the database.&#10;     */&#10;    private fun loadWordsForUser(userId: Long) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            wordRepository.getWordsForUser(userId).collectLatest { words -&gt;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        words = words,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Show the Word Bank modal.&#10;     */&#10;    fun showWordBankModal() {&#10;        _uiState.update { it.copy(isModalVisible = true) }&#10;    }&#10;&#10;    /**&#10;     * Hide the Word Bank modal and reset input state.&#10;     */&#10;    fun hideWordBankModal() {&#10;        _uiState.update {&#10;            it.copy(&#10;                isModalVisible = false,&#10;                wordInput = &quot;&quot;,&#10;                selectedMediaUri = null,&#10;                inputError = null,&#10;                imageError = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update the word input text.&#10;     */&#10;    fun onWordInputChanged(word: String) {&#10;        _uiState.update {&#10;            it.copy(&#10;                wordInput = word.trim(),&#10;                inputError = null // Clear error when user types&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update the selected media URI.&#10;     * Validates the image type before accepting.&#10;     */&#10;    fun onMediaSelected(uri: Uri?) {&#10;        if (uri != null &amp;&amp; !imageStorageManager.isValidImageUri(uri)) {&#10;            _uiState.update {&#10;                it.copy(&#10;                    imageError = &quot;Please select a JPG, PNG, or WebP image&quot;&#10;                )&#10;            }&#10;            return&#10;        }&#10;        _uiState.update {&#10;            it.copy(&#10;                selectedMediaUri = uri,&#10;                imageError = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove the selected media.&#10;     */&#10;    fun onRemoveMedia() {&#10;        _uiState.update {&#10;            it.copy(&#10;                selectedMediaUri = null,&#10;                imageError = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Validate and add the word to the Word Bank.&#10;     * Saves to Room database associated with the current user.&#10;     * If an image is selected, it will be saved to local storage and linked to the word.&#10;     */&#10;    fun addWordToBank() {&#10;        val userId = currentUserId&#10;        if (userId == null) {&#10;            _uiState.update { it.copy(inputError = &quot;Please log in to add words&quot;) }&#10;            return&#10;        }&#10;&#10;        val currentWord = _uiState.value.wordInput.trim()&#10;        val selectedUri = _uiState.value.selectedMediaUri&#10;&#10;        // Basic validation before database operation&#10;        if (!isValidWord(currentWord)) {&#10;            _uiState.update { it.copy(inputError = &quot;Please enter a valid word&quot;) }&#10;            return&#10;        }&#10;&#10;        // Set loading state&#10;        _uiState.update { it.copy(isLoading = true) }&#10;&#10;        // Add word to database on background thread&#10;        viewModelScope.launch {&#10;            // Save image if one is selected&#10;            var imagePath: String? = null&#10;            if (selectedUri != null) {&#10;                when (val saveResult = imageStorageManager.saveImageFromUri(selectedUri)) {&#10;                    is ImageStorageManager.SaveResult.Success -&gt; {&#10;                        imagePath = saveResult.imagePath&#10;                    }&#10;                    is ImageStorageManager.SaveResult.Error -&gt; {&#10;                        _uiState.update {&#10;                            it.copy(&#10;                                imageError = saveResult.message,&#10;                                isLoading = false&#10;                            )&#10;                        }&#10;                        return@launch&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Add word with optional image path&#10;            when (val result = wordRepository.addWord(userId, currentWord, imagePath)) {&#10;                is WordRepository.AddWordResult.Success -&gt; {&#10;                    // Success - close modal and reset input&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            isModalVisible = false,&#10;                            wordInput = &quot;&quot;,&#10;                            selectedMediaUri = null,&#10;                            inputError = null,&#10;                            imageError = null,&#10;                            isLoading = false&#10;                        )&#10;                    }&#10;                }&#10;                is WordRepository.AddWordResult.Error -&gt; {&#10;                    // Clean up saved image if word insertion failed&#10;                    if (imagePath != null) {&#10;                        imageStorageManager.deleteImage(imagePath)&#10;                    }&#10;                    // Show error message&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            inputError = result.message,&#10;                            isLoading = false&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete a word from the Word Bank.&#10;     */&#10;    fun deleteWord(wordId: Long) {&#10;        viewModelScope.launch {&#10;            wordRepository.deleteWord(wordId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle word item click.&#10;     */&#10;    fun onWordClick(word: Word) {&#10;        // Can be extended for word selection, editing, etc.&#10;    }&#10;&#10;    /**&#10;     * Validate if the word is valid.&#10;     * A valid word is non-empty and contains only letters.&#10;     */&#10;    private fun isValidWord(word: String): Boolean {&#10;        return word.isNotBlank() &amp;&amp; word.all { it.isLetter() }&#10;    }&#10;&#10;    /**&#10;     * Check if the current input is valid for submission.&#10;     */&#10;    fun isSubmitEnabled(): Boolean {&#10;        val word = _uiState.value.wordInput.trim()&#10;        return word.isNotBlank() &amp;&amp; word.all { it.isLetter() } &amp;&amp; !_uiState.value.isLoading&#10;    }&#10;}&#10;&#10;/**&#10; * UI State for the Lesson Screen.&#10; */&#10;data class LessonUiState(&#10;    val words: List&lt;Word&gt; = emptyList(),&#10;    val isModalVisible: Boolean = false,&#10;    val wordInput: String = &quot;&quot;,&#10;    val selectedMediaUri: Uri? = null,&#10;    val inputError: String? = null,&#10;    val imageError: String? = null,&#10;    val isLoading: Boolean = false&#10;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/util/ImageStorageManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/util/ImageStorageManager.kt" />
              <option name="updatedContent" value="package com.example.app.util&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.util.UUID&#10;&#10;/**&#10; * Manages image storage for Word Bank words.&#10; * &#10; * Images are stored in the app's internal storage under a dedicated &quot;word_images&quot; directory.&#10; * This ensures images are private to the app and are automatically cleaned up when the app is uninstalled.&#10; */&#10;class ImageStorageManager(private val context: Context) {&#10;&#10;    companion object {&#10;        private const val IMAGES_DIR = &quot;word_images&quot;&#10;        private const val MAX_IMAGE_SIZE = 1024 // Max width/height in pixels&#10;        private const val JPEG_QUALITY = 85&#10;        &#10;        // Supported image MIME types&#10;        val SUPPORTED_MIME_TYPES = listOf(&#10;            &quot;image/jpeg&quot;,&#10;            &quot;image/png&quot;,&#10;            &quot;image/webp&quot;&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Result class for image save operations.&#10;     */&#10;    sealed class SaveResult {&#10;        data class Success(val imagePath: String) : SaveResult()&#10;        data class Error(val message: String) : SaveResult()&#10;    }&#10;&#10;    /**&#10;     * Get the directory for storing word images.&#10;     * Creates the directory if it doesn't exist.&#10;     */&#10;    private fun getImagesDirectory(): File {&#10;        val dir = File(context.filesDir, IMAGES_DIR)&#10;        if (!dir.exists()) {&#10;            dir.mkdirs()&#10;        }&#10;        return dir&#10;    }&#10;&#10;    /**&#10;     * Save an image from a URI to internal storage.&#10;     * &#10;     * The image is:&#10;     * 1. Loaded from the URI&#10;     * 2. Resized if too large (to save storage space)&#10;     * 3. Compressed as JPEG&#10;     * 4. Saved with a unique filename&#10;     *&#10;     * @param uri The source image URI (from gallery or camera)&#10;     * @return SaveResult indicating success with the file path, or an error message&#10;     */&#10;    suspend fun saveImageFromUri(uri: Uri): SaveResult = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Open input stream from URI&#10;            val inputStream = context.contentResolver.openInputStream(uri)&#10;                ?: return@withContext SaveResult.Error(&quot;Unable to open image&quot;)&#10;&#10;            // Decode bitmap with options to get dimensions first&#10;            val options = BitmapFactory.Options().apply {&#10;                inJustDecodeBounds = true&#10;            }&#10;            BitmapFactory.decodeStream(inputStream, null, options)&#10;            inputStream.close()&#10;&#10;            // Calculate sample size for downsampling large images&#10;            val sampleSize = calculateSampleSize(options.outWidth, options.outHeight, MAX_IMAGE_SIZE)&#10;&#10;            // Reopen stream and decode with sample size&#10;            val inputStream2 = context.contentResolver.openInputStream(uri)&#10;                ?: return@withContext SaveResult.Error(&quot;Unable to open image&quot;)&#10;&#10;            val decodeOptions = BitmapFactory.Options().apply {&#10;                inSampleSize = sampleSize&#10;            }&#10;            val bitmap = BitmapFactory.decodeStream(inputStream2, null, decodeOptions)&#10;            inputStream2.close()&#10;&#10;            if (bitmap == null) {&#10;                return@withContext SaveResult.Error(&quot;Unable to decode image&quot;)&#10;            }&#10;&#10;            // Resize if still too large&#10;            val resizedBitmap = resizeBitmapIfNeeded(bitmap, MAX_IMAGE_SIZE)&#10;&#10;            // Generate unique filename&#10;            val filename = &quot;word_${UUID.randomUUID()}.jpg&quot;&#10;            val imageFile = File(getImagesDirectory(), filename)&#10;&#10;            // Save to file&#10;            FileOutputStream(imageFile).use { outputStream -&gt;&#10;                resizedBitmap.compress(Bitmap.CompressFormat.JPEG, JPEG_QUALITY, outputStream)&#10;            }&#10;&#10;            // Clean up bitmaps&#10;            if (resizedBitmap != bitmap) {&#10;                resizedBitmap.recycle()&#10;            }&#10;            bitmap.recycle()&#10;&#10;            SaveResult.Success(imageFile.absolutePath)&#10;        } catch (e: IOException) {&#10;            SaveResult.Error(&quot;Failed to save image: ${e.message}&quot;)&#10;        } catch (e: SecurityException) {&#10;            SaveResult.Error(&quot;Permission denied to access image&quot;)&#10;        } catch (e: OutOfMemoryError) {&#10;            SaveResult.Error(&quot;Image is too large to process&quot;)&#10;        } catch (e: Exception) {&#10;            SaveResult.Error(&quot;An unexpected error occurred: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete an image file from storage.&#10;     *&#10;     * @param imagePath The absolute path to the image file&#10;     * @return true if the file was deleted successfully, false otherwise&#10;     */&#10;    suspend fun deleteImage(imagePath: String): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            val file = File(imagePath)&#10;            if (file.exists() &amp;&amp; file.parentFile?.name == IMAGES_DIR) {&#10;                file.delete()&#10;            } else {&#10;                false&#10;            }&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if an image file exists.&#10;     *&#10;     * @param imagePath The absolute path to the image file&#10;     * @return true if the file exists, false otherwise&#10;     */&#10;    fun imageExists(imagePath: String?): Boolean {&#10;        if (imagePath.isNullOrBlank()) return false&#10;        return File(imagePath).exists()&#10;    }&#10;&#10;    /**&#10;     * Validate if the URI points to a supported image type.&#10;     *&#10;     * @param uri The URI to validate&#10;     * @return true if the URI is a supported image type, false otherwise&#10;     */&#10;    fun isValidImageUri(uri: Uri): Boolean {&#10;        val mimeType = context.contentResolver.getType(uri)&#10;        return mimeType in SUPPORTED_MIME_TYPES&#10;    }&#10;&#10;    /**&#10;     * Calculate the sample size for downsampling large images.&#10;     */&#10;    private fun calculateSampleSize(width: Int, height: Int, maxSize: Int): Int {&#10;        var sampleSize = 1&#10;        if (width &gt; maxSize || height &gt; maxSize) {&#10;            val halfWidth = width / 2&#10;            val halfHeight = height / 2&#10;            while ((halfWidth / sampleSize) &gt;= maxSize &amp;&amp; (halfHeight / sampleSize) &gt;= maxSize) {&#10;                sampleSize *= 2&#10;            }&#10;        }&#10;        return sampleSize&#10;    }&#10;&#10;    /**&#10;     * Resize a bitmap if it exceeds the maximum dimensions.&#10;     */&#10;    private fun resizeBitmapIfNeeded(bitmap: Bitmap, maxSize: Int): Bitmap {&#10;        val width = bitmap.width&#10;        val height = bitmap.height&#10;&#10;        if (width &lt;= maxSize &amp;&amp; height &lt;= maxSize) {&#10;            return bitmap&#10;        }&#10;&#10;        val ratio = width.toFloat() / height.toFloat()&#10;        val newWidth: Int&#10;        val newHeight: Int&#10;&#10;        if (width &gt; height) {&#10;            newWidth = maxSize&#10;            newHeight = (maxSize / ratio).toInt()&#10;        } else {&#10;            newHeight = maxSize&#10;            newWidth = (maxSize * ratio).toInt()&#10;        }&#10;&#10;        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)&#10;    }&#10;&#10;    /**&#10;     * Clean up orphaned images that are no longer referenced by any word.&#10;     * This should be called periodically or when the app starts.&#10;     *&#10;     * @param referencedPaths List of image paths that are still in use&#10;     */&#10;    suspend fun cleanupOrphanedImages(referencedPaths: Set&lt;String&gt;) = withContext(Dispatchers.IO) {&#10;        try {&#10;            val imagesDir = getImagesDirectory()&#10;            imagesDir.listFiles()?.forEach { file -&gt;&#10;                if (file.absolutePath !in referencedPaths) {&#10;                    file.delete()&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            // Silently fail - cleanup is not critical&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;960&quot;&#10;    android:viewportHeight=&quot;960&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#000000&quot;&#10;        android:pathData=&quot;M420,160h120,-120ZM420,800h120,-120ZM360,880l-54,-182q-48,-38 -77,-95t-29,-123q0,-66 29,-123t77,-95l54,-182h240l54,182q48,38 77,95t29,123q0,66 -29,123t-77,95L600,880L360,880ZM480,680q83,0 141.5,-58.5T680,480q0,-83 -58.5,-141.5T480,320q-83,0 -141.5,58.5T280,480q0,83 58.5,141.5T480,680ZM404,210q20,-5 38.5,-8t37.5,-3q19,0 37.5,3t38.5,8l-16,-50L420,160l-16,50ZM420,800h120l16,-50q-20,5 -38.5,7.5T480,760q-19,0 -37.5,-2.5T404,750l16,50Z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>