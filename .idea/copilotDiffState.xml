<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/TutorialActivityCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/TutorialActivityCard.kt" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.tutorialmode&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.example.app.R&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.material3.MaterialTheme&#10;&#10;/**&#10; * Component for displaying a tutorial activity card with icon and title.&#10; * Uses yellow/orange color scheme with dashed border.&#10; *&#10; * @param title The activity title&#10; * @param iconRes The resource ID of the icon image&#10; * @param isSelected Whether the card is selected&#10; * @param onClick Callback when card is clicked&#10; * @param modifier Optional modifier for the card&#10; */&#10;@Composable&#10;fun TutorialActivityCard(&#10;    title: String,&#10;    iconRes: Int,&#10;    isSelected: Boolean = false,&#10;    onClick: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val yellowColor = Color(0xFFEDBB00)&#10;    val lightYellowColor = Color(0x80EDBB00)&#10;    val greenColor = Color(0xFF4CAF50)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(175.dp)&#10;            .clip(RoundedCornerShape(28.dp))&#10;            .background(if (isSelected) yellowColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .then(&#10;                if (!isSelected) {&#10;                    Modifier.drawBehind {&#10;                        val pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 20f), 0f)&#10;                        drawRoundRect(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 12f, pathEffect = pathEffect),&#10;                            cornerRadius = CornerRadius(28.dp.toPx())&#10;                        )&#10;                    }&#10;                } else {&#10;                    Modifier&#10;                }&#10;            )&#10;            .padding(12.dp)&#10;    ) {&#10;        // Selection circle at top right&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .size(36.dp)&#10;                .clip(CircleShape)&#10;                .background(if (isSelected) Color.White else Color.Transparent)&#10;                .drawBehind {&#10;                    if (!isSelected) {&#10;                        drawCircle(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 4f)&#10;                        )&#10;                    }&#10;                },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = greenColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Icon Circle with Border&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Transparent)&#10;                    .drawBehind {&#10;                        drawCircle(&#10;                            color = if (isSelected) Color(0x40FFFFFF) else lightYellowColor,&#10;                            style = Stroke(width = 16f)&#10;                        )&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(CircleShape)&#10;                        .background(if (isSelected) Color.White else yellowColor),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = title,&#10;                        modifier = Modifier.size(60.dp),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Title&#10;            Text(&#10;                text = title,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Normal,&#10;                color = if (isSelected) Color.White else yellowColor,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Unselected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = false,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Selected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardSelectedPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = true,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/components/tutorial/TutorialActivityCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/components/tutorial/TutorialActivityCard.kt" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.tutorialmode.components.tutorial&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.example.app.R&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.material3.MaterialTheme&#10;&#10;/**&#10; * Component for displaying a tutorial activity card with icon and title.&#10; * Uses yellow/orange color scheme with dashed border.&#10; *&#10; * @param title The activity title&#10; * @param iconRes The resource ID of the icon image&#10; * @param isSelected Whether the card is selected&#10; * @param onClick Callback when card is clicked&#10; * @param modifier Optional modifier for the card&#10; */&#10;@Composable&#10;fun TutorialActivityCard(&#10;    title: String,&#10;    iconRes: Int,&#10;    isSelected: Boolean = false,&#10;    onClick: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val yellowColor = Color(0xFFEDBB00)&#10;    val lightYellowColor = Color(0x80EDBB00)&#10;    val greenColor = Color(0xFF4CAF50)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(175.dp)&#10;            .clip(RoundedCornerShape(28.dp))&#10;            .background(if (isSelected) yellowColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .then(&#10;                if (!isSelected) {&#10;                    Modifier.drawBehind {&#10;                        val pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 20f), 0f)&#10;                        drawRoundRect(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 12f, pathEffect = pathEffect),&#10;                            cornerRadius = CornerRadius(28.dp.toPx())&#10;                        )&#10;                    }&#10;                } else {&#10;                    Modifier&#10;                }&#10;            )&#10;            .padding(12.dp)&#10;    ) {&#10;        // Selection circle at top right&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .size(36.dp)&#10;                .clip(CircleShape)&#10;                .background(if (isSelected) Color.White else Color.Transparent)&#10;                .drawBehind {&#10;                    if (!isSelected) {&#10;                        drawCircle(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 4f)&#10;                        )&#10;                    }&#10;                },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = greenColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Icon Circle with Border&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Transparent)&#10;                    .drawBehind {&#10;                        drawCircle(&#10;                            color = if (isSelected) Color(0x40FFFFFF) else lightYellowColor,&#10;                            style = Stroke(width = 16f)&#10;                        )&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(CircleShape)&#10;                        .background(if (isSelected) Color.White else yellowColor),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = title,&#10;                        modifier = Modifier.size(60.dp),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Title&#10;            Text(&#10;                text = title,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Normal,&#10;                color = if (isSelected) Color.White else yellowColor,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Unselected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = false,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Selected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardSelectedPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = true,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;960&quot;&#10;    android:viewportHeight=&quot;960&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#000000&quot;&#10;        android:pathData=&quot;M420,160h120,-120ZM420,800h120,-120ZM360,880l-54,-182q-48,-38 -77,-95t-29,-123q0,-66 29,-123t77,-95l54,-182h240l54,182q48,38 77,95t29,123q0,66 -29,123t-77,95L600,880L360,880ZM480,680q83,0 141.5,-58.5T680,480q0,-83 -58.5,-141.5T480,320q-83,0 -141.5,58.5T280,480q0,83 58.5,141.5T480,680ZM404,210q20,-5 38.5,-8t37.5,-3q19,0 37.5,3t38.5,8l-16,-50L420,160l-16,50ZM420,800h120l16,-50q-20,5 -38.5,7.5T480,760q-19,0 -37.5,-2.5T404,750l16,50Z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wear/src/main/java/com/example/kusho/presentation/practice/PracticeModeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wear/src/main/java/com/example/kusho/presentation/practice/PracticeModeScreen.kt" />
              <option name="originalContent" value="package com.example.kusho.presentation.practice&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.wear.compose.material.CircularProgressIndicator&#10;import androidx.wear.compose.material.MaterialTheme&#10;import androidx.wear.compose.material.Text&#10;import com.example.kusho.R&#10;import com.example.kusho.ml.ClassifierLoadResult&#10;import com.example.kusho.ml.ModelLoader&#10;import com.example.kusho.presentation.theme.AppColors&#10;import com.example.kusho.sensors.MotionSensorManager&#10;import com.example.kusho.speech.TextToSpeechManager&#10;&#10;/**&#10; * Practice Mode screen: countdown -&gt; record gesture -&gt; classify -&gt; show result&#10; */&#10;@Composable&#10;fun PracticeModeScreen() {&#10;    val context = LocalContext.current&#10;    val view = LocalView.current&#10;&#10;    // Use state to track if initialization is complete&#10;    var isInitialized by remember { mutableStateOf(false) }&#10;    var sensorManager by remember { mutableStateOf&lt;MotionSensorManager?&gt;(null) }&#10;    var classifierResult by remember { mutableStateOf&lt;ClassifierLoadResult?&gt;(null) }&#10;&#10;    // Initialize TextToSpeech manager&#10;    val ttsManager = remember { TextToSpeechManager(context) }&#10;&#10;    // Keep screen on during Practice Mode to prevent sleep during air writing&#10;    DisposableEffect(Unit) {&#10;        view.keepScreenOn = true&#10;        onDispose {&#10;            view.keepScreenOn = false&#10;            ttsManager.shutdown()&#10;        }&#10;    }&#10;&#10;    // Initialize dependencies in LaunchedEffect to avoid blocking composition&#10;    LaunchedEffect(Unit) {&#10;        sensorManager = MotionSensorManager(context)&#10;        classifierResult = try {&#10;            ModelLoader.loadDefault(context)&#10;        } catch (e: Exception) {&#10;            ClassifierLoadResult.Error(&quot;Failed to load model: ${e.message}&quot;, e)&#10;        }&#10;        isInitialized = true&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;            .border(8.dp, AppColors.PracticeModeColor, CircleShape),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (!isInitialized || sensorManager == null || classifierResult == null) {&#10;            // Show loading while initializing&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(40.dp),&#10;                    strokeWidth = 4.dp&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;Loading...&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 12.sp&#10;                )&#10;            }&#10;        } else {&#10;            // Show main content once initialized&#10;            PracticeModeContent(&#10;                sensorManager = sensorManager!!,&#10;                classifierResult = classifierResult!!,&#10;                ttsManager = ttsManager&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PracticeModeContent(&#10;    sensorManager: MotionSensorManager,&#10;    classifierResult: ClassifierLoadResult,&#10;    ttsManager: TextToSpeechManager&#10;) {&#10;    val viewModel: PracticeModeViewModel = viewModel(&#10;        factory = PracticeModeViewModelFactory(sensorManager, classifierResult)&#10;    )&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Speak the question when entering QUESTION state&#10;    LaunchedEffect(uiState.state, uiState.currentQuestion) {&#10;        if (uiState.state == PracticeModeViewModel.State.QUESTION &amp;&amp; uiState.currentQuestion != null) {&#10;            ttsManager.speak(uiState.currentQuestion!!.question)&#10;        }&#10;    }&#10;&#10;    // Speak the prediction when we enter RESULT state&#10;    LaunchedEffect(uiState.state, uiState.prediction) {&#10;        if (uiState.state == PracticeModeViewModel.State.RESULT &amp;&amp; uiState.prediction != null) {&#10;            ttsManager.speakLetter(uiState.prediction!!)&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        when (uiState.state) {&#10;            PracticeModeViewModel.State.IDLE -&gt; IdleContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.QUESTION -&gt; QuestionContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.COUNTDOWN -&gt; CountdownContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.RECORDING -&gt; RecordingContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.PROCESSING -&gt; ProcessingContent(uiState)&#10;            PracticeModeViewModel.State.RESULT -&gt; ResultContent(uiState, viewModel)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun IdleContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .clickable(&#10;                indication = null,&#10;                interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }&#10;            ) { viewModel.startRecording() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            // &quot;Tap to Start&quot; text&#10;            Text(&#10;                text = &quot;Tap to Start&quot;,&#10;                color = Color.White,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier.padding(top = 32.dp)&#10;            )&#10;&#10;            // Practice mascot image&#10;            Image(&#10;                painter = painterResource(id = R.drawable.dis_practice),&#10;                contentDescription = &quot;Practice mascot&quot;,&#10;                modifier = Modifier&#10;                    .size(150.dp)&#10;                    .padding(bottom = 32.dp),&#10;                contentScale = ContentScale.Fit&#10;            )&#10;&#10;            // Show score if any questions have been answered&#10;            if (uiState.questionsAnswered &gt; 0) {&#10;                Text(&#10;                    text = &quot;Score: ${uiState.correctAnswers}/${uiState.questionsAnswered}&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 12.sp,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show error message if present&#10;    uiState.errorMessage?.let { error -&gt;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        ErrorBox(error)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun QuestionContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    val question = uiState.currentQuestion&#10;    val isPictureMatch = question?.category == QuestionCategory.PICTURE_MATCH&#10;    val emoji = question?.emoji&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .clickable(&#10;                indication = null,&#10;                interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }&#10;            ) { viewModel.startAnswering() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (isPictureMatch &amp;&amp; emoji != null) {&#10;            // For Picture Match: Show ONLY the emoji centered, no text&#10;            Text(&#10;                text = emoji,&#10;                fontSize = 80.sp,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        } else {&#10;            // For other categories: Show question text with expected letter&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                // Question text&#10;                Text(&#10;                    text = question?.question ?: &quot;&quot;,&#10;                    color = Color.White,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    textAlign = TextAlign.Center,&#10;                    lineHeight = 18.sp,&#10;                    modifier = Modifier.padding(horizontal = 8.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Expected letter (hint)&#10;                Text(&#10;                    text = question?.expectedAnswer ?: &quot;&quot;,&#10;                    color = AppColors.PracticeModeColor,&#10;                    fontSize = 48.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Tap to continue instruction&#10;                Text(&#10;                    text = &quot;Tap to answer&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 12.sp,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CountdownContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;${uiState.countdownSeconds}&quot;,&#10;            color = AppColors.PracticeModeColor,&#10;            fontSize = 80.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            style = MaterialTheme.typography.display1&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RecordingContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator(&#10;                progress = uiState.recordingProgress,&#10;                modifier = Modifier.fillMaxSize(),&#10;                strokeWidth = 8.dp,&#10;                indicatorColor = Color.Green&#10;            )&#10;            Text(text = &quot;✍️&quot;, fontSize = 52.sp)&#10;        }&#10;    }&#10;&#10;}&#10;&#10;@Composable&#10;private fun ProcessingContent(uiState: PracticeModeViewModel.UiState) {&#10;    CircularProgressIndicator(&#10;        modifier = Modifier.size(60.dp),&#10;        strokeWidth = 6.dp&#10;    )&#10;&#10;    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;    Text(&#10;        text = uiState.statusMessage,&#10;        color = AppColors.TextPrimary,&#10;        fontSize = 14.sp,&#10;        textAlign = TextAlign.Center&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun ResultContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    val isCorrect = uiState.isAnswerCorrect == true&#10;    val resultColor = if (isCorrect) Color.Green else Color.Red&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            // Show the user's answer&#10;            Text(&#10;                text = uiState.prediction ?: &quot;?&quot;,&#10;                color = resultColor,&#10;                textAlign = TextAlign.Center,&#10;                fontSize = 64.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                style = MaterialTheme.typography.display1&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Show correct/incorrect feedback&#10;            Text(&#10;                text = if (isCorrect) &quot;Correct! ✓&quot; else &quot;Expected: ${uiState.currentQuestion?.expectedAnswer ?: &quot;?&quot;}&quot;,&#10;                color = if (isCorrect) Color.Green else Color.Yellow,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                textAlign = TextAlign.Center&#10;            )&#10;&#10;            // Show confidence&#10;            uiState.confidence?.let { conf -&gt;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = &quot;${(conf * 100).toInt()}% confidence&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 10.sp,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorBox(message: String) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 8.dp)&#10;            .background(Color.DarkGray, RoundedCornerShape(4.dp))&#10;            .padding(8.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;⚠️ Error&quot;,&#10;            color = Color.Red,&#10;            fontSize = 10.sp&#10;        )&#10;        Text(&#10;            text = message,&#10;            color = Color.Yellow,&#10;            fontSize = 9.sp,&#10;            lineHeight = 11.sp,&#10;            modifier = Modifier.padding(top = 4.dp)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kusho.presentation.practice&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.wear.compose.material.CircularProgressIndicator&#10;import androidx.wear.compose.material.MaterialTheme&#10;import androidx.wear.compose.material.Text&#10;import com.example.kusho.R&#10;import com.example.kusho.ml.ClassifierLoadResult&#10;import com.example.kusho.ml.ModelLoader&#10;import com.example.kusho.presentation.theme.AppColors&#10;import com.example.kusho.sensors.MotionSensorManager&#10;import com.example.kusho.sensors.ShakeDetector&#10;import com.example.kusho.speech.TextToSpeechManager&#10;&#10;/**&#10; * Practice Mode screen: countdown -&gt; record gesture -&gt; classify -&gt; show result&#10; */&#10;@Composable&#10;fun PracticeModeScreen() {&#10;    val context = LocalContext.current&#10;    val view = LocalView.current&#10;&#10;    // Use state to track if initialization is complete&#10;    var isInitialized by remember { mutableStateOf(false) }&#10;    var sensorManager by remember { mutableStateOf&lt;MotionSensorManager?&gt;(null) }&#10;    var classifierResult by remember { mutableStateOf&lt;ClassifierLoadResult?&gt;(null) }&#10;&#10;    // Initialize TextToSpeech manager&#10;    val ttsManager = remember { TextToSpeechManager(context) }&#10;&#10;    // Initialize ShakeDetector for repeating questions&#10;    val shakeDetector = remember { ShakeDetector(context) }&#10;&#10;    // Keep screen on during Practice Mode to prevent sleep during air writing&#10;    DisposableEffect(Unit) {&#10;        view.keepScreenOn = true&#10;        onDispose {&#10;            view.keepScreenOn = false&#10;            ttsManager.shutdown()&#10;            shakeDetector.release()&#10;        }&#10;    }&#10;&#10;    // Initialize dependencies in LaunchedEffect to avoid blocking composition&#10;    LaunchedEffect(Unit) {&#10;        sensorManager = MotionSensorManager(context)&#10;        classifierResult = try {&#10;            ModelLoader.loadDefault(context)&#10;        } catch (e: Exception) {&#10;            ClassifierLoadResult.Error(&quot;Failed to load model: ${e.message}&quot;, e)&#10;        }&#10;        isInitialized = true&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;            .border(8.dp, AppColors.PracticeModeColor, CircleShape),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (!isInitialized || sensorManager == null || classifierResult == null) {&#10;            // Show loading while initializing&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(40.dp),&#10;                    strokeWidth = 4.dp&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot;Loading...&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 12.sp&#10;                )&#10;            }&#10;        } else {&#10;            // Show main content once initialized&#10;            PracticeModeContent(&#10;                sensorManager = sensorManager!!,&#10;                classifierResult = classifierResult!!,&#10;                ttsManager = ttsManager,&#10;                shakeDetector = shakeDetector&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PracticeModeContent(&#10;    sensorManager: MotionSensorManager,&#10;    classifierResult: ClassifierLoadResult,&#10;    ttsManager: TextToSpeechManager,&#10;    shakeDetector: ShakeDetector&#10;) {&#10;    val viewModel: PracticeModeViewModel = viewModel(&#10;        factory = PracticeModeViewModelFactory(sensorManager, classifierResult)&#10;    )&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Speak the question when entering QUESTION state&#10;    LaunchedEffect(uiState.state, uiState.currentQuestion) {&#10;        if (uiState.state == PracticeModeViewModel.State.QUESTION &amp;&amp; uiState.currentQuestion != null) {&#10;            ttsManager.speak(uiState.currentQuestion!!.question)&#10;        }&#10;    }&#10;&#10;    // Manage shake detector for repeating questions in QUESTION state&#10;    DisposableEffect(uiState.state, uiState.currentQuestion) {&#10;        if (uiState.state == PracticeModeViewModel.State.QUESTION &amp;&amp; uiState.currentQuestion != null) {&#10;            // Set up shake listener to repeat the question&#10;            shakeDetector.setOnShakeListener {&#10;                uiState.currentQuestion?.let { question -&gt;&#10;                    ttsManager.speak(question.question)&#10;                }&#10;            }&#10;            shakeDetector.startListening()&#10;        } else {&#10;            // Stop listening when not in QUESTION state&#10;            shakeDetector.stopListening()&#10;        }&#10;&#10;        onDispose {&#10;            shakeDetector.stopListening()&#10;        }&#10;    }&#10;&#10;    // Speak the prediction when we enter RESULT state&#10;    LaunchedEffect(uiState.state, uiState.prediction) {&#10;        if (uiState.state == PracticeModeViewModel.State.RESULT &amp;&amp; uiState.prediction != null) {&#10;            ttsManager.speakLetter(uiState.prediction!!)&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        when (uiState.state) {&#10;            PracticeModeViewModel.State.IDLE -&gt; IdleContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.QUESTION -&gt; QuestionContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.COUNTDOWN -&gt; CountdownContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.RECORDING -&gt; RecordingContent(uiState, viewModel)&#10;            PracticeModeViewModel.State.PROCESSING -&gt; ProcessingContent(uiState)&#10;            PracticeModeViewModel.State.RESULT -&gt; ResultContent(uiState, viewModel)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun IdleContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .clickable(&#10;                indication = null,&#10;                interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }&#10;            ) { viewModel.startRecording() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            // &quot;Tap to Start&quot; text&#10;            Text(&#10;                text = &quot;Tap to Start&quot;,&#10;                color = Color.White,&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier.padding(top = 32.dp)&#10;            )&#10;&#10;            // Practice mascot image&#10;            Image(&#10;                painter = painterResource(id = R.drawable.dis_practice),&#10;                contentDescription = &quot;Practice mascot&quot;,&#10;                modifier = Modifier&#10;                    .size(150.dp)&#10;                    .padding(bottom = 32.dp),&#10;                contentScale = ContentScale.Fit&#10;            )&#10;&#10;            // Show score if any questions have been answered&#10;            if (uiState.questionsAnswered &gt; 0) {&#10;                Text(&#10;                    text = &quot;Score: ${uiState.correctAnswers}/${uiState.questionsAnswered}&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 12.sp,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show error message if present&#10;    uiState.errorMessage?.let { error -&gt;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        ErrorBox(error)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun QuestionContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    val question = uiState.currentQuestion&#10;    val isPictureMatch = question?.category == QuestionCategory.PICTURE_MATCH&#10;    val isTracingCopying = question?.category == QuestionCategory.TRACING_COPYING&#10;    val isUppercaseLowercase = question?.category == QuestionCategory.UPPERCASE_LOWERCASE&#10;    val isLetterSound = question?.category == QuestionCategory.LETTER_SOUND&#10;    val emoji = question?.emoji&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .clickable(&#10;                indication = null,&#10;                interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }&#10;            ) { viewModel.startAnswering() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (isPictureMatch &amp;&amp; emoji != null) {&#10;            // For Picture Match: Show ONLY the emoji centered, no text&#10;            Text(&#10;                text = emoji,&#10;                fontSize = 80.sp,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        } else if (isTracingCopying || isUppercaseLowercase) {&#10;            // For Tracing &amp; Copying and Uppercase/Lowercase: Show ONLY the letter centered, no text&#10;            Text(&#10;                text = question?.expectedAnswer ?: &quot;&quot;,&#10;                color = AppColors.PracticeModeColor,&#10;                fontSize = 80.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        } else if (isLetterSound) {&#10;            // For Letter Sound Match (Phonics): Show ONLY the question avatar&#10;            Image(&#10;                painter = painterResource(id = R.drawable.dis_question),&#10;                contentDescription = &quot;Question avatar&quot;,&#10;                modifier = Modifier.size(120.dp),&#10;                contentScale = ContentScale.Fit&#10;            )&#10;        } else {&#10;            // For other categories: Show question text with expected letter&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center,&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                // Question text&#10;                Text(&#10;                    text = question?.question ?: &quot;&quot;,&#10;                    color = Color.White,&#10;                    fontSize = 14.sp,&#10;                    fontWeight = FontWeight.Medium,&#10;                    textAlign = TextAlign.Center,&#10;                    lineHeight = 18.sp,&#10;                    modifier = Modifier.padding(horizontal = 8.dp)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Expected letter (hint)&#10;                Text(&#10;                    text = question?.expectedAnswer ?: &quot;&quot;,&#10;                    color = AppColors.PracticeModeColor,&#10;                    fontSize = 48.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Tap to continue instruction&#10;                Text(&#10;                    text = &quot;Tap to answer&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 12.sp,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CountdownContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;${uiState.countdownSeconds}&quot;,&#10;            color = AppColors.PracticeModeColor,&#10;            fontSize = 80.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            style = MaterialTheme.typography.display1&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RecordingContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator(&#10;                progress = uiState.recordingProgress,&#10;                modifier = Modifier.fillMaxSize(),&#10;                strokeWidth = 8.dp,&#10;                indicatorColor = Color.Green&#10;            )&#10;            Text(text = &quot;✍️&quot;, fontSize = 52.sp)&#10;        }&#10;    }&#10;&#10;}&#10;&#10;@Composable&#10;private fun ProcessingContent(uiState: PracticeModeViewModel.UiState) {&#10;    CircularProgressIndicator(&#10;        modifier = Modifier.size(60.dp),&#10;        strokeWidth = 6.dp&#10;    )&#10;&#10;    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;    Text(&#10;        text = uiState.statusMessage,&#10;        color = AppColors.TextPrimary,&#10;        fontSize = 14.sp,&#10;        textAlign = TextAlign.Center&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun ResultContent(&#10;    uiState: PracticeModeViewModel.UiState,&#10;    viewModel: PracticeModeViewModel&#10;) {&#10;    val isCorrect = uiState.isAnswerCorrect == true&#10;    val resultColor = if (isCorrect) Color.Green else Color.Red&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            // Show the user's answer&#10;            Text(&#10;                text = uiState.prediction ?: &quot;?&quot;,&#10;                color = resultColor,&#10;                textAlign = TextAlign.Center,&#10;                fontSize = 64.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                style = MaterialTheme.typography.display1&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Show correct/incorrect feedback&#10;            Text(&#10;                text = if (isCorrect) &quot;Correct! ✓&quot; else &quot;Expected: ${uiState.currentQuestion?.expectedAnswer ?: &quot;?&quot;}&quot;,&#10;                color = if (isCorrect) Color.Green else Color.Yellow,&#10;                fontSize = 14.sp,&#10;                fontWeight = FontWeight.Medium,&#10;                textAlign = TextAlign.Center&#10;            )&#10;&#10;            // Show confidence&#10;            uiState.confidence?.let { conf -&gt;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = &quot;${(conf * 100).toInt()}% confidence&quot;,&#10;                    color = AppColors.TextSecondary,&#10;                    fontSize = 10.sp,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorBox(message: String) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 8.dp)&#10;            .background(Color.DarkGray, RoundedCornerShape(4.dp))&#10;            .padding(8.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;⚠️ Error&quot;,&#10;            color = Color.Red,&#10;            fontSize = 10.sp&#10;        )&#10;        Text(&#10;            text = message,&#10;            color = Color.Yellow,&#10;            fontSize = 9.sp,&#10;            lineHeight = 11.sp,&#10;            modifier = Modifier.padding(top = 4.dp)&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wear/src/main/java/com/example/kusho/sensors/ShakeDetector.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wear/src/main/java/com/example/kusho/sensors/ShakeDetector.kt" />
              <option name="updatedContent" value="package com.example.kusho.sensors&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.util.Log&#10;import kotlin.math.sqrt&#10;&#10;/**&#10; * Detects shake/tilt gestures on the watch.&#10; * Used in Practice Mode to allow users to repeat the current question.&#10; */&#10;class ShakeDetector(private val context: Context) : SensorEventListener {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ShakeDetector&quot;&#10;        &#10;        // Shake detection thresholds&#10;        private const val SHAKE_THRESHOLD_GRAVITY = 2.5f  // Acceleration threshold (in G)&#10;        private const val SHAKE_SLOP_TIME_MS = 500        // Minimum time between shakes&#10;        private const val SHAKE_COUNT_RESET_TIME_MS = 2000 // Reset shake count after this time&#10;        &#10;        // Tilt detection thresholds  &#10;        private const val TILT_THRESHOLD_DEGREES = 45f    // Tilt angle threshold&#10;        private const val TILT_COOLDOWN_MS = 1000         // Cooldown between tilt detections&#10;    }&#10;&#10;    private val sensorManager: SensorManager? =&#10;        context.getSystemService(Context.SENSOR_SERVICE) as? SensorManager&#10;&#10;    private var accelerometer: Sensor? = null&#10;    &#10;    // Shake detection state&#10;    private var shakeTimestamp: Long = 0&#10;    private var shakeCount: Int = 0&#10;    &#10;    // Tilt detection state&#10;    private var lastTiltTimestamp: Long = 0&#10;    private var initialGravity: FloatArray? = null&#10;    private var gravityValues = FloatArray(3)&#10;    &#10;    // Listener for shake/tilt events&#10;    private var onShakeListener: (() -&gt; Unit)? = null&#10;    &#10;    @Volatile&#10;    private var isListening: Boolean = false&#10;&#10;    /**&#10;     * Set the callback for when a shake/tilt gesture is detected.&#10;     */&#10;    fun setOnShakeListener(listener: () -&gt; Unit) {&#10;        onShakeListener = listener&#10;    }&#10;&#10;    /**&#10;     * Start listening for shake/tilt gestures.&#10;     */&#10;    fun startListening() {&#10;        if (isListening) return&#10;        &#10;        val sm = sensorManager ?: run {&#10;            Log.e(TAG, &quot;SensorManager not available&quot;)&#10;            return&#10;        }&#10;&#10;        accelerometer = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)&#10;        if (accelerometer == null) {&#10;            Log.e(TAG, &quot;Accelerometer not available&quot;)&#10;            return&#10;        }&#10;&#10;        isListening = true&#10;        shakeCount = 0&#10;        initialGravity = null&#10;        &#10;        // Use a slower sampling rate since we don't need high precision&#10;        sm.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_UI)&#10;        Log.d(TAG, &quot;Started listening for shake/tilt gestures&quot;)&#10;    }&#10;&#10;    /**&#10;     * Stop listening for shake/tilt gestures.&#10;     */&#10;    fun stopListening() {&#10;        if (!isListening) return&#10;        &#10;        isListening = false&#10;        sensorManager?.unregisterListener(this)&#10;        shakeCount = 0&#10;        initialGravity = null&#10;        Log.d(TAG, &quot;Stopped listening for shake/tilt gestures&quot;)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent) {&#10;        if (!isListening) return&#10;        if (event.sensor.type != Sensor.TYPE_ACCELEROMETER) return&#10;&#10;        val x = event.values[0]&#10;        val y = event.values[1]&#10;        val z = event.values[2]&#10;&#10;        // Apply low-pass filter to isolate gravity&#10;        val alpha = 0.8f&#10;        gravityValues[0] = alpha * gravityValues[0] + (1 - alpha) * x&#10;        gravityValues[1] = alpha * gravityValues[1] + (1 - alpha) * y&#10;        gravityValues[2] = alpha * gravityValues[2] + (1 - alpha) * z&#10;&#10;        // Check for shake (sudden acceleration)&#10;        checkForShake(x, y, z)&#10;        &#10;        // Check for tilt (orientation change)&#10;        checkForTilt()&#10;    }&#10;&#10;    /**&#10;     * Detect shake by measuring acceleration magnitude above threshold.&#10;     */&#10;    private fun checkForShake(x: Float, y: Float, z: Float) {&#10;        // Calculate acceleration magnitude relative to gravity&#10;        val gX = x / SensorManager.GRAVITY_EARTH&#10;        val gY = y / SensorManager.GRAVITY_EARTH&#10;        val gZ = z / SensorManager.GRAVITY_EARTH&#10;&#10;        // Calculate total G-force&#10;        val gForce = sqrt(gX * gX + gY * gY + gZ * gZ)&#10;&#10;        if (gForce &gt; SHAKE_THRESHOLD_GRAVITY) {&#10;            val now = System.currentTimeMillis()&#10;            &#10;            // Check if enough time has passed since last shake&#10;            if (shakeTimestamp + SHAKE_SLOP_TIME_MS &gt; now) {&#10;                return&#10;            }&#10;&#10;            // Reset shake count if too much time has passed&#10;            if (shakeTimestamp + SHAKE_COUNT_RESET_TIME_MS &lt; now) {&#10;                shakeCount = 0&#10;            }&#10;&#10;            shakeTimestamp = now&#10;            shakeCount++&#10;&#10;            Log.d(TAG, &quot;Shake detected! Count: $shakeCount, G-force: $gForce&quot;)&#10;            &#10;            // Trigger callback on first shake (no need to wait for multiple shakes)&#10;            if (shakeCount &gt;= 1) {&#10;                onShakeListener?.invoke()&#10;                shakeCount = 0 // Reset after triggering&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Detect tilt by measuring significant change in device orientation.&#10;     */&#10;    private fun checkForTilt() {&#10;        val now = System.currentTimeMillis()&#10;        &#10;        // Check cooldown&#10;        if (now - lastTiltTimestamp &lt; TILT_COOLDOWN_MS) {&#10;            return&#10;        }&#10;&#10;        // Store initial gravity reference&#10;        if (initialGravity == null) {&#10;            initialGravity = gravityValues.clone()&#10;            return&#10;        }&#10;&#10;        val initial = initialGravity!!&#10;        &#10;        // Calculate the angle difference using dot product&#10;        val magnitude1 = sqrt(initial[0] * initial[0] + initial[1] * initial[1] + initial[2] * initial[2])&#10;        val magnitude2 = sqrt(gravityValues[0] * gravityValues[0] + gravityValues[1] * gravityValues[1] + gravityValues[2] * gravityValues[2])&#10;        &#10;        if (magnitude1 &lt; 0.1f || magnitude2 &lt; 0.1f) return&#10;        &#10;        val dotProduct = (initial[0] * gravityValues[0] + initial[1] * gravityValues[1] + initial[2] * gravityValues[2])&#10;        val cosAngle = dotProduct / (magnitude1 * magnitude2)&#10;        &#10;        // Clamp to valid range for acos&#10;        val clampedCos = cosAngle.coerceIn(-1f, 1f)&#10;        val angleDegrees = Math.toDegrees(kotlin.math.acos(clampedCos).toDouble()).toFloat()&#10;&#10;        if (angleDegrees &gt; TILT_THRESHOLD_DEGREES) {&#10;            Log.d(TAG, &quot;Tilt detected! Angle: $angleDegrees degrees&quot;)&#10;            lastTiltTimestamp = now&#10;            initialGravity = gravityValues.clone() // Update reference&#10;            onShakeListener?.invoke()&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // No-op&#10;    }&#10;&#10;    /**&#10;     * Clean up resources.&#10;     */&#10;    fun release() {&#10;        stopListening()&#10;        onShakeListener = null&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>