<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wear/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wear/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.kusho&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.kusho&quot;&#10;        minSdk = 30&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    useLibrary(&quot;wear-sdk&quot;)&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:common&quot;))&#10;    implementation(platform(libs.compose.bom))&#10;    implementation(libs.ui)&#10;    implementation(libs.ui.graphics)&#10;    implementation(libs.ui.tooling.preview)&#10;    implementation(libs.compose.material)&#10;    implementation(libs.compose.foundation)&#10;    implementation(libs.wear.tooling.preview)&#10;    implementation(libs.activity.compose)&#10;    implementation(libs.core.splashscreen)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.10.2&quot;)&#10;    androidTestImplementation(platform(libs.compose.bom))&#10;    androidTestImplementation(libs.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.kusho&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.kusho&quot;&#10;        minSdk = 30&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    useLibrary(&quot;wear-sdk&quot;)&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:common&quot;))&#10;    implementation(platform(libs.compose.bom))&#10;    implementation(libs.ui)&#10;    implementation(libs.ui.graphics)&#10;    implementation(libs.ui.tooling.preview)&#10;    implementation(libs.compose.material)&#10;    implementation(libs.compose.foundation)&#10;    implementation(libs.wear.tooling.preview)&#10;    implementation(libs.activity.compose)&#10;    implementation(libs.core.splashscreen)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.10.2&quot;)&#10;    implementation(&quot;androidx.wear.compose:compose-navigation:1.3.0&quot;)&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.6&quot;)&#10;    androidTestImplementation(platform(libs.compose.bom))&#10;    androidTestImplementation(libs.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wear/src/main/java/com/example/kusho/presentation/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wear/src/main/java/com/example/kusho/presentation/MainActivity.kt" />
              <option name="originalContent" value="package com.example.kusho.presentation&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.wear.tooling.preview.devices.WearDevices&#10;import com.example.kusho.R&#10;import com.example.kusho.common.MessageService&#10;import com.google.android.gms.wearable.NodeClient&#10;import androidx.wear.compose.material.MaterialTheme&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.unit.Density&#10;import android.graphics.Paint&#10;import kotlin.math.PI&#10;import kotlin.math.cos&#10;import kotlin.math.sin&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setTheme(android.R.style.Theme_DeviceDefault)&#10;        setContent {&#10;            WearApp(messageService = null, nodeClient = null)&#10;        }&#10;    }&#10;}&#10;&#10;// Constants&#10;private const val ARC_STROKE_WIDTH = 24f&#10;private const val ARC_STROKE_WIDTH_DP = 16f&#10;private const val ARC_SWEEP_ANGLE = 70f&#10;private const val LETTER_SPACING_FACTOR = 1.15f&#10;private const val TEXT_SIZE_SP = 13f&#10;private const val LOGO_SIZE_DP = 100f&#10;private const val RADIUS_FACTOR = 2.3f&#10;&#10;// Arc positions (in degrees)&#10;private const val PRACTICE_MODE_ANGLE = 90f  // Bottom&#10;private const val TUTORIAL_MODE_ANGLE = 180f // Left&#10;private const val LEARN_MODE_ANGLE = 0f      // Right&#10;&#10;// Arc colors&#10;private val PracticeModeColor = Color(0xFF42A5F5)&#10;private val TutorialModeColor = Color(0xFFFFC107)&#10;private val LearnModeColor = Color(0xFFB388FF)&#10;&#10;@Suppress(&quot;UNUSED_PARAMETER&quot;)&#10;@Composable&#10;fun WearApp(messageService: MessageService?, nodeClient: NodeClient?) {&#10;    MaterialTheme {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            // Center logo&#10;            Image(&#10;                painter = painterResource(id = R.drawable.ic_kusho),&#10;                contentDescription = &quot;Kusho Logo&quot;,&#10;                modifier = Modifier.size(LOGO_SIZE_DP.dp),&#10;                contentScale = ContentScale.Fit&#10;            )&#10;&#10;            // Draw mode arcs&#10;            val density = LocalDensity.current&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val centerX = size.width / 2f&#10;                val centerY = size.height / 2f&#10;                val radius = size.width / RADIUS_FACTOR&#10;&#10;                // Draw all three mode arcs&#10;                drawModeArc(&#10;                    centerX = centerX,&#10;                    centerY = centerY,&#10;                    radius = radius,&#10;                    centerAngle = PRACTICE_MODE_ANGLE,&#10;                    text = &quot;Practice Mode&quot;,&#10;                    color = PracticeModeColor,&#10;                    density = density&#10;                )&#10;&#10;                drawModeArc(&#10;                    centerX = centerX,&#10;                    centerY = centerY,&#10;                    radius = radius,&#10;                    centerAngle = TUTORIAL_MODE_ANGLE,&#10;                    text = &quot;Tutorial Mode&quot;,&#10;                    color = TutorialModeColor,&#10;                    density = density&#10;                )&#10;&#10;                drawModeArc(&#10;                    centerX = centerX,&#10;                    centerY = centerY,&#10;                    radius = radius,&#10;                    centerAngle = LEARN_MODE_ANGLE,&#10;                    text = &quot;Learn Mode&quot;,&#10;                    color = LearnModeColor,&#10;                    density = density&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Draws a circular arc pill with curved text for a mode button&#10; */&#10;private fun DrawScope.drawModeArc(&#10;    centerX: Float,&#10;    centerY: Float,&#10;    radius: Float,&#10;    centerAngle: Float,&#10;    text: String,&#10;    color: Color,&#10;    density: Density&#10;) {&#10;    val startAngle = centerAngle - (ARC_SWEEP_ANGLE / 2f)&#10;&#10;    // Draw the arc background&#10;    val arcPath = Path()&#10;    arcPath.addArc(&#10;        oval = androidx.compose.ui.geometry.Rect(&#10;            left = centerX - radius,&#10;            top = centerY - radius,&#10;            right = centerX + radius,&#10;            bottom = centerY + radius&#10;        ),&#10;        startAngleDegrees = startAngle,&#10;        sweepAngleDegrees = ARC_SWEEP_ANGLE&#10;    )&#10;&#10;    drawPath(&#10;        path = arcPath,&#10;        color = color,&#10;        style = Stroke(&#10;            width = ARC_STROKE_WIDTH.dp.toPx(),&#10;            cap = androidx.compose.ui.graphics.StrokeCap.Round&#10;        )&#10;    )&#10;&#10;    // Draw curved text along the arc&#10;    drawCurvedText(&#10;        text = text.reversed(),&#10;        centerX = centerX,&#10;        centerY = centerY,&#10;        radius = radius,&#10;        startAngle = startAngle,&#10;        sweepAngle = ARC_SWEEP_ANGLE,&#10;        density = density&#10;    )&#10;}&#10;&#10;/**&#10; * Draws text curved along a circular arc path&#10; */&#10;private fun DrawScope.drawCurvedText(&#10;    text: String,&#10;    centerX: Float,&#10;    centerY: Float,&#10;    radius: Float,&#10;    startAngle: Float,&#10;    sweepAngle: Float,&#10;    density: Density&#10;) {&#10;    val textPaint = Paint().apply {&#10;        color = android.graphics.Color.WHITE&#10;        textSize = with(density) { TEXT_SIZE_SP.sp.toPx() }&#10;        textAlign = Paint.Align.CENTER&#10;        isAntiAlias = true&#10;    }&#10;&#10;    val arcStrokeWidth = ARC_STROKE_WIDTH_DP.dp.toPx()&#10;    val textRadius = radius + (arcStrokeWidth / 4f)&#10;&#10;    // Calculate character widths and spacing&#10;    val charWidths = FloatArray(text.length)&#10;    textPaint.getTextWidths(text, charWidths)&#10;    val totalTextWidth = charWidths.sum() * LETTER_SPACING_FACTOR&#10;    val textArcAngle = (totalTextWidth / (2f * PI.toFloat() * textRadius)) * 360f&#10;    val textStartAngle = startAngle + sweepAngle - (sweepAngle - textArcAngle) / 2f&#10;&#10;    // Draw each character along the curve&#10;    var currentAngle = textStartAngle&#10;    for (i in text.indices.reversed()) {&#10;        val char = text[i].toString()&#10;        val charWidth = charWidths[i] * LETTER_SPACING_FACTOR&#10;        val charAngle = (charWidth / (2f * PI.toFloat() * textRadius)) * 360f&#10;&#10;        currentAngle -= charAngle / 2f&#10;&#10;        val angleInRadians = Math.toRadians(currentAngle.toDouble())&#10;        val x = centerX + textRadius * cos(angleInRadians).toFloat()&#10;        val y = centerY + textRadius * sin(angleInRadians).toFloat()&#10;&#10;        drawContext.canvas.nativeCanvas.save()&#10;        drawContext.canvas.nativeCanvas.translate(x, y)&#10;        drawContext.canvas.nativeCanvas.rotate(currentAngle - 90f)&#10;        drawContext.canvas.nativeCanvas.drawText(char, 0f, 0f, textPaint)&#10;        drawContext.canvas.nativeCanvas.restore()&#10;&#10;        currentAngle -= charAngle / 2f&#10;    }&#10;}&#10;&#10;@Preview(device = WearDevices.SMALL_ROUND, showSystemUi = true)&#10;@Composable&#10;fun DefaultPreview() {&#10;    WearApp(&#10;        messageService = null,&#10;        nodeClient = null&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kusho.presentation&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.wear.tooling.preview.devices.WearDevices&#10;import com.example.kusho.R&#10;import com.example.kusho.common.MessageService&#10;import com.google.android.gms.wearable.NodeClient&#10;import androidx.wear.compose.material.MaterialTheme&#10;import androidx.wear.compose.material.Text&#10;import androidx.wear.compose.material.Scaffold&#10;import androidx.wear.compose.material.TimeText&#10;import androidx.wear.compose.navigation.SwipeDismissableNavHost&#10;import androidx.wear.compose.navigation.composable&#10;import androidx.wear.compose.navigation.rememberSwipeDismissableNavController&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Density&#10;import androidx.navigation.NavHostController&#10;import android.graphics.Paint&#10;import kotlin.math.PI&#10;import kotlin.math.cos&#10;import kotlin.math.sin&#10;import kotlin.math.atan2&#10;import kotlin.math.sqrt&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setTheme(android.R.style.Theme_DeviceDefault)&#10;        setContent {&#10;            WearApp(messageService = null, nodeClient = null)&#10;        }&#10;    }&#10;}&#10;&#10;// Navigation Routes&#10;private object Routes {&#10;    const val HOME = &quot;home&quot;&#10;    const val PRACTICE_MODE = &quot;practice_mode&quot;&#10;    const val TUTORIAL_MODE = &quot;tutorial_mode&quot;&#10;    const val LEARN_MODE = &quot;learn_mode&quot;&#10;}&#10;&#10;// Constants&#10;private const val ARC_STROKE_WIDTH = 24f&#10;private const val ARC_STROKE_WIDTH_DP = 16f&#10;private const val ARC_SWEEP_ANGLE = 70f&#10;private const val LETTER_SPACING_FACTOR = 1.15f&#10;private const val TEXT_SIZE_SP = 13f&#10;private const val LOGO_SIZE_DP = 100f&#10;private const val RADIUS_FACTOR = 2.3f&#10;&#10;// Arc positions (in degrees)&#10;private const val PRACTICE_MODE_ANGLE = 90f  // Bottom&#10;private const val TUTORIAL_MODE_ANGLE = 180f // Left&#10;private const val LEARN_MODE_ANGLE = 0f      // Right&#10;&#10;// Arc colors&#10;private val PracticeModeColor = Color(0xFF42A5F5)&#10;private val TutorialModeColor = Color(0xFFFFC107)&#10;private val LearnModeColor = Color(0xFFB388FF)&#10;&#10;@Suppress(&quot;UNUSED_PARAMETER&quot;)&#10;@Composable&#10;fun WearApp(messageService: MessageService?, nodeClient: NodeClient?) {&#10;    MaterialTheme {&#10;        val navController = rememberSwipeDismissableNavController()&#10;        &#10;        SwipeDismissableNavHost(&#10;            navController = navController,&#10;            startDestination = Routes.HOME&#10;        ) {&#10;            // Home screen with mode arcs&#10;            composable(Routes.HOME) {&#10;                HomeScreen(navController = navController)&#10;            }&#10;            &#10;            // Practice Mode screen&#10;            composable(Routes.PRACTICE_MODE) {&#10;                ModeScreen(&#10;                    modeName = &quot;Practice Mode&quot;,&#10;                    modeColor = PracticeModeColor&#10;                )&#10;            }&#10;            &#10;            // Tutorial Mode screen&#10;            composable(Routes.TUTORIAL_MODE) {&#10;                ModeScreen(&#10;                    modeName = &quot;Tutorial Mode&quot;,&#10;                    modeColor = TutorialModeColor&#10;                )&#10;            }&#10;            &#10;            // Learn Mode screen&#10;            composable(Routes.LEARN_MODE) {&#10;                ModeScreen(&#10;                    modeName = &quot;Learn Mode&quot;,&#10;                    modeColor = LearnModeColor&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HomeScreen(navController: NavHostController) {&#10;    val density = LocalDensity.current&#10;    &#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;            .pointerInput(Unit) {&#10;                detectTapGestures { offset -&gt;&#10;                    val centerX = size.width / 2f&#10;                    val centerY = size.height / 2f&#10;                    val radius = size.width / RADIUS_FACTOR&#10;                    &#10;                    // Calculate which arc was tapped&#10;                    val tappedMode = getTappedMode(&#10;                        tapX = offset.x,&#10;                        tapY = offset.y,&#10;                        centerX = centerX,&#10;                        centerY = centerY,&#10;                        radius = radius&#10;                    )&#10;                    &#10;                    // Navigate to the appropriate mode screen&#10;                    when (tappedMode) {&#10;                        &quot;practice&quot; -&gt; navController.navigate(Routes.PRACTICE_MODE)&#10;                        &quot;tutorial&quot; -&gt; navController.navigate(Routes.TUTORIAL_MODE)&#10;                        &quot;learn&quot; -&gt; navController.navigate(Routes.LEARN_MODE)&#10;                    }&#10;                }&#10;            },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Center logo&#10;        Image(&#10;            painter = painterResource(id = R.drawable.ic_kusho),&#10;            contentDescription = &quot;Kusho Logo&quot;,&#10;            modifier = Modifier.size(LOGO_SIZE_DP.dp),&#10;            contentScale = ContentScale.Fit&#10;        )&#10;&#10;        // Draw mode arcs&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            val centerX = size.width / 2f&#10;            val centerY = size.height / 2f&#10;            val radius = size.width / RADIUS_FACTOR&#10;&#10;            // Draw all three mode arcs&#10;            drawModeArc(&#10;                centerX = centerX,&#10;                centerY = centerY,&#10;                radius = radius,&#10;                centerAngle = PRACTICE_MODE_ANGLE,&#10;                text = &quot;Practice Mode&quot;,&#10;                color = PracticeModeColor,&#10;                density = density&#10;            )&#10;&#10;            drawModeArc(&#10;                centerX = centerX,&#10;                centerY = centerY,&#10;                radius = radius,&#10;                centerAngle = TUTORIAL_MODE_ANGLE,&#10;                text = &quot;Tutorial Mode&quot;,&#10;                color = TutorialModeColor,&#10;                density = density&#10;            )&#10;&#10;            drawModeArc(&#10;                centerX = centerX,&#10;                centerY = centerY,&#10;                radius = radius,&#10;                centerAngle = LEARN_MODE_ANGLE,&#10;                text = &quot;Learn Mode&quot;,&#10;                color = LearnModeColor,&#10;                density = density&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModeScreen(modeName: String, modeColor: Color) {&#10;    Scaffold(&#10;        timeText = {&#10;            TimeText()&#10;        }&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = modeName,&#10;                color = modeColor,&#10;                fontSize = 24.sp,&#10;                textAlign = TextAlign.Center&#10;            )&#10;            &#10;            Text(&#10;                text = &quot;Swipe right to go back&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier.padding(top = 16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Determines which arc mode was tapped based on tap coordinates&#10; */&#10;private fun getTappedMode(&#10;    tapX: Float,&#10;    tapY: Float,&#10;    centerX: Float,&#10;    centerY: Float,&#10;    radius: Float&#10;): String? {&#10;    // Calculate distance from center&#10;    val dx = tapX - centerX&#10;    val dy = tapY - centerY&#10;    val distance = sqrt(dx * dx + dy * dy)&#10;    &#10;    // Check if tap is within the arc ring area&#10;    val innerRadius = radius - (ARC_STROKE_WIDTH * 2)&#10;    val outerRadius = radius + (ARC_STROKE_WIDTH * 2)&#10;    &#10;    if (distance &lt; innerRadius || distance &gt; outerRadius) {&#10;        return null // Tap outside arc area&#10;    }&#10;    &#10;    // Calculate angle of tap&#10;    var angle = Math.toDegrees(atan2(dy.toDouble(), dx.toDouble())).toFloat()&#10;    if (angle &lt; 0) angle += 360f&#10;    &#10;    // Check which arc was tapped based on angle ranges&#10;    // Practice Mode: bottom (around 90째)&#10;    val practiceStart = PRACTICE_MODE_ANGLE - (ARC_SWEEP_ANGLE / 2f)&#10;    val practiceEnd = PRACTICE_MODE_ANGLE + (ARC_SWEEP_ANGLE / 2f)&#10;    if (angle &gt;= practiceStart &amp;&amp; angle &lt;= practiceEnd) {&#10;        return &quot;practice&quot;&#10;    }&#10;    &#10;    // Tutorial Mode: left (around 180째)&#10;    val tutorialStart = TUTORIAL_MODE_ANGLE - (ARC_SWEEP_ANGLE / 2f)&#10;    val tutorialEnd = TUTORIAL_MODE_ANGLE + (ARC_SWEEP_ANGLE / 2f)&#10;    if (angle &gt;= tutorialStart &amp;&amp; angle &lt;= tutorialEnd) {&#10;        return &quot;tutorial&quot;&#10;    }&#10;    &#10;    // Learn Mode: right (around 0째/360째)&#10;    val learnStart = LEARN_MODE_ANGLE - (ARC_SWEEP_ANGLE / 2f)&#10;    val learnEnd = LEARN_MODE_ANGLE + (ARC_SWEEP_ANGLE / 2f)&#10;    if ((angle &gt;= 360f + learnStart || angle &lt;= learnEnd) || &#10;        (angle &gt;= learnStart &amp;&amp; angle &lt;= learnEnd)) {&#10;        return &quot;learn&quot;&#10;    }&#10;    &#10;    return null&#10;}&#10;&#10;/**&#10; * Draws a circular arc pill with curved text for a mode button&#10; */&#10;private fun DrawScope.drawModeArc(&#10;    centerX: Float,&#10;    centerY: Float,&#10;    radius: Float,&#10;    centerAngle: Float,&#10;    text: String,&#10;    color: Color,&#10;    density: Density&#10;) {&#10;    val startAngle = centerAngle - (ARC_SWEEP_ANGLE / 2f)&#10;&#10;    // Draw the arc background&#10;    val arcPath = Path()&#10;    arcPath.addArc(&#10;        oval = androidx.compose.ui.geometry.Rect(&#10;            left = centerX - radius,&#10;            top = centerY - radius,&#10;            right = centerX + radius,&#10;            bottom = centerY + radius&#10;        ),&#10;        startAngleDegrees = startAngle,&#10;        sweepAngleDegrees = ARC_SWEEP_ANGLE&#10;    )&#10;&#10;    drawPath(&#10;        path = arcPath,&#10;        color = color,&#10;        style = Stroke(&#10;            width = ARC_STROKE_WIDTH.dp.toPx(),&#10;            cap = androidx.compose.ui.graphics.StrokeCap.Round&#10;        )&#10;    )&#10;&#10;    // Draw curved text along the arc&#10;    drawCurvedText(&#10;        text = text.reversed(),&#10;        centerX = centerX,&#10;        centerY = centerY,&#10;        radius = radius,&#10;        startAngle = startAngle,&#10;        sweepAngle = ARC_SWEEP_ANGLE,&#10;        density = density&#10;    )&#10;}&#10;&#10;/**&#10; * Draws text curved along a circular arc path&#10; */&#10;private fun DrawScope.drawCurvedText(&#10;    text: String,&#10;    centerX: Float,&#10;    centerY: Float,&#10;    radius: Float,&#10;    startAngle: Float,&#10;    sweepAngle: Float,&#10;    density: Density&#10;) {&#10;    val textPaint = Paint().apply {&#10;        color = android.graphics.Color.WHITE&#10;        textSize = with(density) { TEXT_SIZE_SP.sp.toPx() }&#10;        textAlign = Paint.Align.CENTER&#10;        isAntiAlias = true&#10;    }&#10;&#10;    val arcStrokeWidth = ARC_STROKE_WIDTH_DP.dp.toPx()&#10;    val textRadius = radius + (arcStrokeWidth / 4f)&#10;&#10;    // Calculate character widths and spacing&#10;    val charWidths = FloatArray(text.length)&#10;    textPaint.getTextWidths(text, charWidths)&#10;    val totalTextWidth = charWidths.sum() * LETTER_SPACING_FACTOR&#10;    val textArcAngle = (totalTextWidth / (2f * PI.toFloat() * textRadius)) * 360f&#10;    val textStartAngle = startAngle + sweepAngle - (sweepAngle - textArcAngle) / 2f&#10;&#10;    // Draw each character along the curve&#10;    var currentAngle = textStartAngle&#10;    for (i in text.indices.reversed()) {&#10;        val char = text[i].toString()&#10;        val charWidth = charWidths[i] * LETTER_SPACING_FACTOR&#10;        val charAngle = (charWidth / (2f * PI.toFloat() * textRadius)) * 360f&#10;&#10;        currentAngle -= charAngle / 2f&#10;&#10;        val angleInRadians = Math.toRadians(currentAngle.toDouble())&#10;        val x = centerX + textRadius * cos(angleInRadians).toFloat()&#10;        val y = centerY + textRadius * sin(angleInRadians).toFloat()&#10;&#10;        drawContext.canvas.nativeCanvas.save()&#10;        drawContext.canvas.nativeCanvas.translate(x, y)&#10;        drawContext.canvas.nativeCanvas.rotate(currentAngle - 90f)&#10;        drawContext.canvas.nativeCanvas.drawText(char, 0f, 0f, textPaint)&#10;        drawContext.canvas.nativeCanvas.restore()&#10;&#10;        currentAngle -= charAngle / 2f&#10;    }&#10;}&#10;&#10;@Preview(device = WearDevices.SMALL_ROUND, showSystemUi = true)&#10;@Composable&#10;fun DefaultPreview() {&#10;    WearApp(&#10;        messageService = null,&#10;        nodeClient = null&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>