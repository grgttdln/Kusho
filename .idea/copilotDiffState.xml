<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/service/WatchConnectionManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/service/WatchConnectionManager.kt" />
              <option name="originalContent" value="package com.example.app.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.bluetooth.BluetoothAdapter&#10;import android.bluetooth.BluetoothManager&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import androidx.wear.remote.interactions.RemoteActivityHelper&#10;import com.google.android.gms.wearable.*&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.concurrent.Executors&#10;&#10;enum class ConnectionState {&#10;    BLUETOOTH_OFF,           // Bluetooth is disabled&#10;    NO_WATCH,               // Bluetooth on, but no watch paired at all&#10;    WATCH_PAIRED_NO_APP,    // Watch paired, but Kusho app not installed/running&#10;    WATCH_CONNECTED         // Watch paired AND Kusho app running&#10;}&#10;&#10;data class WatchDeviceInfo(&#10;    val name: String = &quot;Unknown Watch&quot;,&#10;    val model: String = &quot;&quot;,&#10;    val nodeId: String = &quot;&quot;,&#10;    val isConnected: Boolean = false,&#10;    val connectionState: ConnectionState = ConnectionState.BLUETOOTH_OFF,&#10;    val batteryPercentage: Int? = null,&#10;    val lastUpdated: Long = System.currentTimeMillis()&#10;)&#10;&#10;class WatchConnectionManager private constructor(private val context: Context) {&#10;    &#10;    private val nodeClient: NodeClient by lazy { Wearable.getNodeClient(context) }&#10;    private val messageClient: MessageClient by lazy { Wearable.getMessageClient(context) }&#10;    private val capabilityClient: CapabilityClient by lazy { Wearable.getCapabilityClient(context) }&#10;    &#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    &#10;    private val _deviceInfo = MutableStateFlow(WatchDeviceInfo())&#10;    val deviceInfo: StateFlow&lt;WatchDeviceInfo&gt; = _deviceInfo.asStateFlow()&#10;    &#10;    // Flow for Learn Mode skip commands from watch&#10;    private val _learnModeSkipTrigger = MutableStateFlow(0L) // Timestamp of skip event&#10;    val learnModeSkipTrigger: StateFlow&lt;Long&gt; = _learnModeSkipTrigger.asStateFlow()&#10;    &#10;    // Flow for letter input events from watch (for Write the Word mode)&#10;    data class LetterInputEvent(&#10;        val letter: Char = ' ',&#10;        val letterIndex: Int = 0,&#10;        val timestamp: Long = 0L&#10;    )&#10;    private val _letterInputEvent = MutableStateFlow(LetterInputEvent())&#10;    val letterInputEvent: StateFlow&lt;LetterInputEvent&gt; = _letterInputEvent.asStateFlow()&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: WatchConnectionManager? = null&#10;        private const val TAG = &quot;WatchConnectionMgr&quot;&#10;        private const val NOTIFICATION_CHANNEL_ID = &quot;kusho_watch_install&quot;&#10;        private const val NOTIFICATION_ID_INSTALL_APP = 1001&#10;        &#10;        fun getInstance(context: Context): WatchConnectionManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: WatchConnectionManager(context.applicationContext).also {&#10;                    INSTANCE = it&#10;                }&#10;            }&#10;        }&#10;        &#10;        private const val CAPABILITY_WEAR_APP = &quot;kusho_wear_app&quot;&#10;        private const val MESSAGE_PATH_REQUEST_BATTERY = &quot;/request_battery&quot;&#10;        private const val MESSAGE_PATH_REQUEST_DEVICE_INFO = &quot;/request_device_info&quot;&#10;        private const val MESSAGE_PATH_BATTERY_STATUS = &quot;/battery_status&quot;&#10;        private const val MESSAGE_PATH_DEVICE_INFO = &quot;/device_info&quot;&#10;        private const val MESSAGE_PATH_PING = &quot;/kusho/ping&quot;&#10;        private const val MESSAGE_PATH_PONG = &quot;/kusho/pong&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_SKIP = &quot;/learn_mode_skip&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_STARTED = &quot;/learn_mode_started&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_ENDED = &quot;/learn_mode_ended&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_WORD_DATA = &quot;/learn_mode_word_data&quot;&#10;        private const val MESSAGE_PATH_LETTER_INPUT = &quot;/learn_mode_letter_input&quot;&#10;        private const val MESSAGE_PATH_LETTER_RESULT = &quot;/learn_mode_letter_result&quot;&#10;        private const val MESSAGE_PATH_WORD_COMPLETE = &quot;/learn_mode_word_complete&quot;&#10;        private const val POLLING_INTERVAL_MS = 30000L // 30 seconds&#10;    }&#10;    &#10;    private var monitoringJob: Job? = null&#10;    private val messageListener = MessageClient.OnMessageReceivedListener { messageEvent -&gt;&#10;        Log.d(TAG, &quot; Phone received message: ${messageEvent.path}&quot;)&#10;        handleIncomingMessage(messageEvent)&#10;    }&#10;    &#10;    private val capabilityListener = CapabilityClient.OnCapabilityChangedListener { capabilityInfo -&gt;&#10;        // Real-time updates when watch connects/disconnects&#10;        scope.launch {&#10;            checkConnection()&#10;        }&#10;    }&#10;    &#10;    // Bluetooth state receiver for real-time Bluetooth ON/OFF detection&#10;    private val bluetoothStateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                BluetoothAdapter.ACTION_STATE_CHANGED -&gt; {&#10;                    val state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)&#10;                    when (state) {&#10;                        BluetoothAdapter.STATE_OFF -&gt; {&#10;                            // Bluetooth turned off - immediately update to disconnected&#10;                            _deviceInfo.value = WatchDeviceInfo(&#10;                                isConnected = false,&#10;                                connectionState = ConnectionState.BLUETOOTH_OFF&#10;                            )&#10;                        }&#10;                        BluetoothAdapter.STATE_ON -&gt; {&#10;                            // Bluetooth turned on - check for watches&#10;                            scope.launch {&#10;                                checkConnection()&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    init {&#10;        messageClient.addListener(messageListener)&#10;        // Add capability listener for real-time watch connection changes&#10;        capabilityClient.addListener(capabilityListener, CAPABILITY_WEAR_APP)&#10;        &#10;        // Register Bluetooth state receiver&#10;        val filter = IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED)&#10;        context.registerReceiver(bluetoothStateReceiver, filter)&#10;    }&#10;    &#10;    /**&#10;     * Start monitoring watch connection and battery status&#10;     */&#10;    fun startMonitoring() {&#10;        monitoringJob?.cancel()&#10;        monitoringJob = scope.launch {&#10;            while (isActive) {&#10;                checkConnection()&#10;&#10;                // If watch is connected but battery is still 0, request it again&#10;                val currentDevice = _deviceInfo.value&#10;                if (currentDevice.isConnected &amp;&amp; &#10;                    currentDevice.connectionState == ConnectionState.WATCH_CONNECTED &amp;&amp;&#10;                    currentDevice.batteryPercentage == 0) {&#10;                    // Try to get battery info from all connected nodes with Kusho app&#10;                    try {&#10;                        val capabilityInfo = capabilityClient&#10;                            .getCapability(CAPABILITY_WEAR_APP, CapabilityClient.FILTER_REACHABLE)&#10;                            .await()&#10;                        capabilityInfo.nodes.firstOrNull()?.let { node -&gt;&#10;                            requestBatteryStatus(node)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                &#10;                delay(POLLING_INTERVAL_MS)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Stop monitoring watch connection&#10;     */&#10;    fun stopMonitoring() {&#10;        monitoringJob?.cancel()&#10;        monitoringJob = null&#10;    }&#10;    &#10;    /**&#10;     * Check if watch is connected and update device info&#10;     * Now with proper Bluetooth state checking&#10;     */&#10;    suspend fun checkConnection(): Boolean {&#10;        return try {&#10;            // STEP 1: Check if Bluetooth is enabled&#10;            val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as? BluetoothManager&#10;            val bluetoothAdapter = bluetoothManager?.adapter&#10;            &#10;            if (bluetoothAdapter == null || !bluetoothAdapter.isEnabled) {&#10;                // Bluetooth is OFF or not available&#10;                _deviceInfo.value = WatchDeviceInfo(&#10;                    isConnected = false,&#10;                    connectionState = ConnectionState.BLUETOOTH_OFF&#10;                )&#10;                return false&#10;            }&#10;            &#10;            // STEP 2: Bluetooth is ON - Check for ANY connected Wear OS nodes&#10;            val allNodes = nodeClient.connectedNodes.await()&#10;            &#10;            // STEP 3: Check for nodes with Kusho capability&#10;            val capabilityInfo = capabilityClient&#10;                .getCapability(CAPABILITY_WEAR_APP, CapabilityClient.FILTER_REACHABLE)&#10;                .await()&#10;            &#10;            val watchNodeWithApp = capabilityInfo.nodes.firstOrNull()&#10;            &#10;            when {&#10;                watchNodeWithApp != null -&gt; {&#10;                    // CASE 3: Watch paired AND Kusho app installed/running&#10;                    val deviceName = getDeviceName(watchNodeWithApp.displayName)&#10;                    _deviceInfo.value = WatchDeviceInfo(&#10;                        name = deviceName,&#10;                        nodeId = watchNodeWithApp.id,&#10;                        isConnected = true,&#10;                        connectionState = ConnectionState.WATCH_CONNECTED,&#10;                        batteryPercentage = 0, // Will be updated by battery request&#10;                        lastUpdated = System.currentTimeMillis()&#10;                    )&#10;                    requestBatteryStatus(watchNodeWithApp)&#10;                    return true&#10;                }&#10;                &#10;                allNodes.isNotEmpty() -&gt; {&#10;                    // CASE 2: Watch paired, but no Kusho app&#10;                    val deviceName = getDeviceName(allNodes.first().displayName)&#10;                    _deviceInfo.value = WatchDeviceInfo(&#10;                        name = deviceName,&#10;                        nodeId = allNodes.first().id,&#10;                        isConnected = false,&#10;                        connectionState = ConnectionState.WATCH_PAIRED_NO_APP,&#10;                        batteryPercentage = 0,&#10;                        lastUpdated = System.currentTimeMillis()&#10;                    )&#10;                    return false&#10;                }&#10;                &#10;                else -&gt; {&#10;                    // CASE 1: Bluetooth ON, but no watch paired&#10;                    _deviceInfo.value = WatchDeviceInfo(&#10;                        isConnected = false,&#10;                        connectionState = ConnectionState.NO_WATCH&#10;                    )&#10;                    return false&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            _deviceInfo.value = WatchDeviceInfo(&#10;                isConnected = false,&#10;                connectionState = ConnectionState.NO_WATCH&#10;            )&#10;            false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Request battery status from connected watch&#10;     * Now with retry mechanism to ensure battery data is received&#10;     */&#10;    private fun requestBatteryStatus(node: Node) {&#10;        scope.launch {&#10;            try {&#10;                // Send multiple requests with delays to ensure watch receives it&#10;                repeat(3) { attempt -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_REQUEST_BATTERY,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                    &#10;                    // Wait a bit between requests&#10;                    if (attempt &lt; 2) {&#10;                        delay(2000L) // 2 seconds between requests&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Notify watch that Learn Mode session has started&#10;     */&#10;    fun notifyLearnModeStarted() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LEARN_MODE_STARTED,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Learn Mode started notification sent to watch&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to notify watch of Learn Mode start&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Notify watch that Learn Mode session has ended&#10;     */&#10;    fun notifyLearnModeEnded() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LEARN_MODE_ENDED,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Learn Mode ended notification sent to watch&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to notify watch of Learn Mode end&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Send word data to watch for fill-in-the-blanks mode&#10;     * @param word The full word&#10;     * @param maskedIndex Index of the masked letter (for fill-in-the-blank)&#10;     * @param configurationType The configuration type (e.g., &quot;Fill in the Blank&quot;)&#10;     */&#10;    fun sendLearnModeWordData(word: String, maskedIndex: Int, configurationType: String) {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                &#10;                // Create JSON payload&#10;                val jsonPayload = org.json.JSONObject().apply {&#10;                    put(&quot;word&quot;, word)&#10;                    put(&quot;maskedIndex&quot;, maskedIndex)&#10;                    put(&quot;configurationType&quot;, configurationType)&#10;                }.toString()&#10;                &#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LEARN_MODE_WORD_DATA,&#10;                        jsonPayload.toByteArray()&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Word data sent to watch: $word (masked: $maskedIndex, type: $configurationType)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send word data to watch&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Send letter validation result back to watch for Write the Word mode&#10;     * @param isCorrect Whether the input letter was correct&#10;     * @param currentIndex Current letter index being spelled (next letter to input)&#10;     * @param totalLetters Total letters in the word&#10;     */&#10;    fun sendLetterResult(isCorrect: Boolean, currentIndex: Int, totalLetters: Int) {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                val payload = org.json.JSONObject().apply {&#10;                    put(&quot;isCorrect&quot;, isCorrect)&#10;                    put(&quot;currentIndex&quot;, currentIndex)&#10;                    put(&quot;totalLetters&quot;, totalLetters)&#10;                }.toString()&#10;&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LETTER_RESULT,&#10;                        payload.toByteArray()&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Letter result sent: correct=$isCorrect, index=$currentIndex/$totalLetters&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send letter result&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Notify watch that word was completed successfully&#10;     */&#10;    fun sendWordComplete() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_WORD_COMPLETE,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Word complete notification sent&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send word complete&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Request device info from connected watch&#10;     */&#10;    fun requestDeviceInfo() {&#10;        scope.launch {&#10;            try {&#10;                val currentInfo = _deviceInfo.value&#10;                if (currentInfo.isConnected &amp;&amp; currentInfo.nodeId.isNotEmpty()) {&#10;                    messageClient.sendMessage(&#10;                        currentInfo.nodeId,&#10;                        MESSAGE_PATH_REQUEST_DEVICE_INFO,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Request battery from currently connected watch&#10;     * Call this when UI needs fresh battery data (e.g., Dashboard onResume)&#10;     */&#10;    fun requestBatteryFromConnectedWatch() {&#10;        scope.launch {&#10;            try {&#10;                val currentDevice = _deviceInfo.value&#10;                &#10;                Log.d(TAG, &quot; Phone requesting battery - isConnected: ${currentDevice.isConnected}, state: ${currentDevice.connectionState}, nodeId: ${currentDevice.nodeId}&quot;)&#10;                &#10;                // Only request if watch is fully connected with app&#10;                if (currentDevice.isConnected &amp;&amp; &#10;                    currentDevice.connectionState == ConnectionState.WATCH_CONNECTED &amp;&amp;&#10;                    currentDevice.nodeId.isNotEmpty()) {&#10;                    &#10;                    // Send immediate battery request (with retry)&#10;                    repeat(3) { attempt -&gt;&#10;                        Log.d(TAG, &quot; Sending battery request (attempt ${attempt + 1}/3) to ${currentDevice.nodeId}&quot;)&#10;                        messageClient.sendMessage(&#10;                            currentDevice.nodeId,&#10;                            MESSAGE_PATH_REQUEST_BATTERY,&#10;                            ByteArray(0)&#10;                        ).await()&#10;                        Log.d(TAG, &quot;✅ Battery request sent successfully (attempt ${attempt + 1}/3)&quot;)&#10;                        &#10;                        if (attempt &lt; 2) {&#10;                            delay(1000L) // 1 second between retries&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.w(TAG, &quot;⚠️ Cannot request battery - watch not fully connected&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send battery request&quot;, e)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Handle incoming messages from watch&#10;     */&#10;    private fun handleIncomingMessage(messageEvent: MessageEvent) {&#10;        Log.d(TAG, &quot; Processing message: ${messageEvent.path}&quot;)&#10;        when (messageEvent.path) {&#10;            MESSAGE_PATH_PING -&gt; {&#10;                // Watch is checking if Kusho app is running - respond with PONG&#10;                Log.d(TAG, &quot; Received PING from watch, sending PONG response&quot;)&#10;                scope.launch {&#10;                    try {&#10;                        messageClient.sendMessage(&#10;                            messageEvent.sourceNodeId,&#10;                            MESSAGE_PATH_PONG,&#10;                            &quot;pong&quot;.toByteArray()&#10;                        ).await()&#10;                        Log.d(TAG, &quot;✅ PONG sent successfully&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;❌ Failed to send PONG&quot;, e)&#10;                    }&#10;                }&#10;            }&#10;            MESSAGE_PATH_BATTERY_STATUS -&gt; {&#10;                val batteryLevel = String(messageEvent.data).toIntOrNull()&#10;                Log.d(TAG, &quot; Received battery status: ${batteryLevel?.let { &quot;$it%&quot; } ?: &quot;parsing failed&quot;}&quot;)&#10;                _deviceInfo.value = _deviceInfo.value.copy(&#10;                    batteryPercentage = batteryLevel,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;                Log.d(TAG, &quot;✅ Updated device info with battery: ${batteryLevel?.let { &quot;$it%&quot; } ?: &quot;null&quot;}&quot;)&#10;            }&#10;            MESSAGE_PATH_DEVICE_INFO -&gt; {&#10;                val deviceName = String(messageEvent.data)&#10;                Log.d(TAG, &quot; Received device info: $deviceName&quot;)&#10;                _deviceInfo.value = _deviceInfo.value.copy(&#10;                    name = deviceName,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;            }&#10;            MESSAGE_PATH_LEARN_MODE_SKIP -&gt; {&#10;                Log.d(TAG, &quot;⏭️ Received Learn Mode skip command from watch&quot;)&#10;                // Trigger skip by updating the timestamp&#10;                _learnModeSkipTrigger.value = System.currentTimeMillis()&#10;            }&#10;            MESSAGE_PATH_LETTER_INPUT -&gt; {&#10;                try {&#10;                    val jsonString = String(messageEvent.data)&#10;                    val json = org.json.JSONObject(jsonString)&#10;                    val letter = json.optString(&quot;letter&quot;, &quot;&quot;).firstOrNull() ?: return&#10;                    val letterIndex = json.optInt(&quot;letterIndex&quot;, 0)&#10;                    Log.d(TAG, &quot; Received letter input from watch: $letter at index $letterIndex&quot;)&#10;                    _letterInputEvent.value = LetterInputEvent(&#10;                        letter = letter, // Keep exact case - don't convert to uppercase&#10;                        letterIndex = letterIndex,&#10;                        timestamp = System.currentTimeMillis()&#10;                    )&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;❌ Failed to parse letter input&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Parse device name to get user-friendly name&#10;     */&#10;    private fun getDeviceName(displayName: String): String {&#10;        return when {&#10;            displayName.contains(&quot;Galaxy Watch&quot;, ignoreCase = true) -&gt; displayName&#10;            displayName.contains(&quot;Watch&quot;, ignoreCase = true) -&gt; displayName&#10;            else -&gt; &quot;Smartwatch&quot; // Default name for non-Galaxy watches&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get list of all connected nodes&#10;     */&#10;    suspend fun getConnectedNodes(): List&lt;Node&gt; {&#10;        return try {&#10;            nodeClient.connectedNodes.await()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            emptyList()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clear connection state (useful for testing or when user manually disconnects)&#10;     */&#10;    fun clearConnection() {&#10;        _deviceInfo.value = WatchDeviceInfo(&#10;            isConnected = false,&#10;            connectionState = ConnectionState.NO_WATCH&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Open Play Store on watch using RemoteActivityHelper&#10;     * This works even if the Kusho app is NOT installed on the watch yet.&#10;     */&#10;    fun openPlayStoreOnWatch() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                &#10;                if (nodes.isEmpty()) {&#10;                    Log.w(TAG, &quot;⚠️ Cannot open Play Store - no connected watch nodes&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // RemoteActivityHelper needs a context and an executor&#10;                val remoteActivityHelper = RemoteActivityHelper(context, Executors.newSingleThreadExecutor())&#10;&#10;                // The Intent to open the Play Store specifically for YOUR app package&#10;                val intent = Intent(Intent.ACTION_VIEW)&#10;                    .addCategory(Intent.CATEGORY_BROWSABLE)&#10;                    .setData(Uri.parse(&quot;market://details?id=com.example.kusho&quot;))&#10;&#10;                for (node in nodes) {&#10;                    remoteActivityHelper.startRemoteActivity(&#10;                        intent,&#10;                        node.id&#10;                    )&#10;                    Log.d(TAG, &quot;✅ Sent Remote Intent to open Play Store on: ${node.displayName}&quot;)&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to open Play Store on watch&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Create notification channel for install prompts&#10;     */&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                NOTIFICATION_CHANNEL_ID,&#10;                &quot;Watch App Installation&quot;,&#10;                NotificationManager.IMPORTANCE_HIGH&#10;            ).apply {&#10;                description = &quot;Notifications for installing the Kusho watch app&quot;&#10;                enableVibration(true)&#10;            }&#10;            &#10;            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clean up resources&#10;     * Note: Does NOT cancel scope since this is a singleton that persists across screens&#10;     */&#10;    fun cleanup() {&#10;        stopMonitoring()&#10;        messageClient.removeListener(messageListener)&#10;        capabilityClient.removeListener(capabilityListener)&#10;        try {&#10;            context.unregisterReceiver(bluetoothStateReceiver)&#10;        } catch (e: Exception) {&#10;            // Receiver might not be registered&#10;        }&#10;        // DO NOT cancel scope - singleton needs persistent scope&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.app.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.bluetooth.BluetoothAdapter&#10;import android.bluetooth.BluetoothManager&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import androidx.wear.remote.interactions.RemoteActivityHelper&#10;import com.google.android.gms.wearable.*&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.concurrent.Executors&#10;&#10;enum class ConnectionState {&#10;    BLUETOOTH_OFF,           // Bluetooth is disabled&#10;    NO_WATCH,               // Bluetooth on, but no watch paired at all&#10;    WATCH_PAIRED_NO_APP,    // Watch paired, but Kusho app not installed/running&#10;    WATCH_CONNECTED         // Watch paired AND Kusho app running&#10;}&#10;&#10;data class WatchDeviceInfo(&#10;    val name: String = &quot;Unknown Watch&quot;,&#10;    val model: String = &quot;&quot;,&#10;    val nodeId: String = &quot;&quot;,&#10;    val isConnected: Boolean = false,&#10;    val connectionState: ConnectionState = ConnectionState.BLUETOOTH_OFF,&#10;    val batteryPercentage: Int? = null,&#10;    val lastUpdated: Long = System.currentTimeMillis()&#10;)&#10;&#10;class WatchConnectionManager private constructor(private val context: Context) {&#10;    &#10;    private val nodeClient: NodeClient by lazy { Wearable.getNodeClient(context) }&#10;    private val messageClient: MessageClient by lazy { Wearable.getMessageClient(context) }&#10;    private val capabilityClient: CapabilityClient by lazy { Wearable.getCapabilityClient(context) }&#10;    &#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    &#10;    private val _deviceInfo = MutableStateFlow(WatchDeviceInfo())&#10;    val deviceInfo: StateFlow&lt;WatchDeviceInfo&gt; = _deviceInfo.asStateFlow()&#10;    &#10;    // Flow for Learn Mode skip commands from watch&#10;    private val _learnModeSkipTrigger = MutableStateFlow(0L) // Timestamp of skip event&#10;    val learnModeSkipTrigger: StateFlow&lt;Long&gt; = _learnModeSkipTrigger.asStateFlow()&#10;    &#10;    // Flow for letter input events from watch (for Write the Word mode)&#10;    data class LetterInputEvent(&#10;        val letter: Char = ' ',&#10;        val letterIndex: Int = 0,&#10;        val timestamp: Long = 0L&#10;    )&#10;    private val _letterInputEvent = MutableStateFlow(LetterInputEvent())&#10;    val letterInputEvent: StateFlow&lt;LetterInputEvent&gt; = _letterInputEvent.asStateFlow()&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: WatchConnectionManager? = null&#10;        private const val TAG = &quot;WatchConnectionMgr&quot;&#10;        private const val NOTIFICATION_CHANNEL_ID = &quot;kusho_watch_install&quot;&#10;        private const val NOTIFICATION_ID_INSTALL_APP = 1001&#10;        &#10;        fun getInstance(context: Context): WatchConnectionManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: WatchConnectionManager(context.applicationContext).also {&#10;                    INSTANCE = it&#10;                }&#10;            }&#10;        }&#10;        &#10;        private const val CAPABILITY_WEAR_APP = &quot;kusho_wear_app&quot;&#10;        private const val MESSAGE_PATH_REQUEST_BATTERY = &quot;/request_battery&quot;&#10;        private const val MESSAGE_PATH_REQUEST_DEVICE_INFO = &quot;/request_device_info&quot;&#10;        private const val MESSAGE_PATH_BATTERY_STATUS = &quot;/battery_status&quot;&#10;        private const val MESSAGE_PATH_DEVICE_INFO = &quot;/device_info&quot;&#10;        private const val MESSAGE_PATH_PING = &quot;/kusho/ping&quot;&#10;        private const val MESSAGE_PATH_PONG = &quot;/kusho/pong&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_SKIP = &quot;/learn_mode_skip&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_STARTED = &quot;/learn_mode_started&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_ENDED = &quot;/learn_mode_ended&quot;&#10;        private const val MESSAGE_PATH_LEARN_MODE_WORD_DATA = &quot;/learn_mode_word_data&quot;&#10;        private const val MESSAGE_PATH_LETTER_INPUT = &quot;/learn_mode_letter_input&quot;&#10;        private const val MESSAGE_PATH_LETTER_RESULT = &quot;/learn_mode_letter_result&quot;&#10;        private const val MESSAGE_PATH_WORD_COMPLETE = &quot;/learn_mode_word_complete&quot;&#10;        private const val POLLING_INTERVAL_MS = 30000L // 30 seconds&#10;    }&#10;    &#10;    private var monitoringJob: Job? = null&#10;    private val messageListener = MessageClient.OnMessageReceivedListener { messageEvent -&gt;&#10;        Log.d(TAG, &quot; Phone received message: ${messageEvent.path}&quot;)&#10;        handleIncomingMessage(messageEvent)&#10;    }&#10;    &#10;    private val capabilityListener = CapabilityClient.OnCapabilityChangedListener { capabilityInfo -&gt;&#10;        // Real-time updates when watch connects/disconnects&#10;        scope.launch {&#10;            checkConnection()&#10;        }&#10;    }&#10;    &#10;    // Bluetooth state receiver for real-time Bluetooth ON/OFF detection&#10;    private val bluetoothStateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                BluetoothAdapter.ACTION_STATE_CHANGED -&gt; {&#10;                    val state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)&#10;                    when (state) {&#10;                        BluetoothAdapter.STATE_OFF -&gt; {&#10;                            // Bluetooth turned off - immediately update to disconnected&#10;                            _deviceInfo.value = WatchDeviceInfo(&#10;                                isConnected = false,&#10;                                connectionState = ConnectionState.BLUETOOTH_OFF&#10;                            )&#10;                        }&#10;                        BluetoothAdapter.STATE_ON -&gt; {&#10;                            // Bluetooth turned on - check for watches&#10;                            scope.launch {&#10;                                checkConnection()&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    init {&#10;        messageClient.addListener(messageListener)&#10;        // Add capability listener for real-time watch connection changes&#10;        capabilityClient.addListener(capabilityListener, CAPABILITY_WEAR_APP)&#10;        &#10;        // Register Bluetooth state receiver&#10;        val filter = IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED)&#10;        context.registerReceiver(bluetoothStateReceiver, filter)&#10;    }&#10;    &#10;    /**&#10;     * Start monitoring watch connection and battery status&#10;     */&#10;    fun startMonitoring() {&#10;        monitoringJob?.cancel()&#10;        monitoringJob = scope.launch {&#10;            while (isActive) {&#10;                checkConnection()&#10;&#10;                // If watch is connected but battery is still 0, request it again&#10;                val currentDevice = _deviceInfo.value&#10;                if (currentDevice.isConnected &amp;&amp; &#10;                    currentDevice.connectionState == ConnectionState.WATCH_CONNECTED &amp;&amp;&#10;                    currentDevice.batteryPercentage == 0) {&#10;                    // Try to get battery info from all connected nodes with Kusho app&#10;                    try {&#10;                        val capabilityInfo = capabilityClient&#10;                            .getCapability(CAPABILITY_WEAR_APP, CapabilityClient.FILTER_REACHABLE)&#10;                            .await()&#10;                        capabilityInfo.nodes.firstOrNull()?.let { node -&gt;&#10;                            requestBatteryStatus(node)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                &#10;                delay(POLLING_INTERVAL_MS)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Stop monitoring watch connection&#10;     */&#10;    fun stopMonitoring() {&#10;        monitoringJob?.cancel()&#10;        monitoringJob = null&#10;    }&#10;    &#10;    /**&#10;     * Check if watch is connected and update device info&#10;     * Now with proper Bluetooth state checking&#10;     */&#10;    suspend fun checkConnection(): Boolean {&#10;        return try {&#10;            // STEP 1: Check if Bluetooth is enabled&#10;            val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as? BluetoothManager&#10;            val bluetoothAdapter = bluetoothManager?.adapter&#10;            &#10;            if (bluetoothAdapter == null || !bluetoothAdapter.isEnabled) {&#10;                // Bluetooth is OFF or not available&#10;                _deviceInfo.value = WatchDeviceInfo(&#10;                    isConnected = false,&#10;                    connectionState = ConnectionState.BLUETOOTH_OFF&#10;                )&#10;                return false&#10;            }&#10;            &#10;            // STEP 2: Bluetooth is ON - Check for ANY connected Wear OS nodes&#10;            val allNodes = nodeClient.connectedNodes.await()&#10;            &#10;            // STEP 3: Check for nodes with Kusho capability&#10;            val capabilityInfo = capabilityClient&#10;                .getCapability(CAPABILITY_WEAR_APP, CapabilityClient.FILTER_REACHABLE)&#10;                .await()&#10;            &#10;            val watchNodeWithApp = capabilityInfo.nodes.firstOrNull()&#10;            &#10;            when {&#10;                watchNodeWithApp != null -&gt; {&#10;                    // CASE 3: Watch paired AND Kusho app installed/running&#10;                    val deviceName = getDeviceName(watchNodeWithApp.displayName)&#10;                    _deviceInfo.value = WatchDeviceInfo(&#10;                        name = deviceName,&#10;                        nodeId = watchNodeWithApp.id,&#10;                        isConnected = true,&#10;                        connectionState = ConnectionState.WATCH_CONNECTED,&#10;                        batteryPercentage = 0, // Will be updated by battery request&#10;                        lastUpdated = System.currentTimeMillis()&#10;                    )&#10;                    requestBatteryStatus(watchNodeWithApp)&#10;                    return true&#10;                }&#10;                &#10;                allNodes.isNotEmpty() -&gt; {&#10;                    // CASE 2: Watch paired, but no Kusho app&#10;                    val deviceName = getDeviceName(allNodes.first().displayName)&#10;                    _deviceInfo.value = WatchDeviceInfo(&#10;                        name = deviceName,&#10;                        nodeId = allNodes.first().id,&#10;                        isConnected = false,&#10;                        connectionState = ConnectionState.WATCH_PAIRED_NO_APP,&#10;                        batteryPercentage = 0,&#10;                        lastUpdated = System.currentTimeMillis()&#10;                    )&#10;                    return false&#10;                }&#10;                &#10;                else -&gt; {&#10;                    // CASE 1: Bluetooth ON, but no watch paired&#10;                    _deviceInfo.value = WatchDeviceInfo(&#10;                        isConnected = false,&#10;                        connectionState = ConnectionState.NO_WATCH&#10;                    )&#10;                    return false&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            _deviceInfo.value = WatchDeviceInfo(&#10;                isConnected = false,&#10;                connectionState = ConnectionState.NO_WATCH&#10;            )&#10;            false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Request battery status from connected watch&#10;     * Now with retry mechanism to ensure battery data is received&#10;     */&#10;    private fun requestBatteryStatus(node: Node) {&#10;        scope.launch {&#10;            try {&#10;                // Send multiple requests with delays to ensure watch receives it&#10;                repeat(3) { attempt -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_REQUEST_BATTERY,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                    &#10;                    // Wait a bit between requests&#10;                    if (attempt &lt; 2) {&#10;                        delay(2000L) // 2 seconds between requests&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Notify watch that Learn Mode session has started&#10;     */&#10;    fun notifyLearnModeStarted() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LEARN_MODE_STARTED,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Learn Mode started notification sent to watch&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to notify watch of Learn Mode start&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Notify watch that Learn Mode session has ended&#10;     */&#10;    fun notifyLearnModeEnded() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LEARN_MODE_ENDED,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Learn Mode ended notification sent to watch&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to notify watch of Learn Mode end&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Send word data to watch for fill-in-the-blanks mode&#10;     * @param word The full word&#10;     * @param maskedIndex Index of the masked letter (for fill-in-the-blank)&#10;     * @param configurationType The configuration type (e.g., &quot;Fill in the Blank&quot;)&#10;     */&#10;    fun sendLearnModeWordData(word: String, maskedIndex: Int, configurationType: String) {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                &#10;                // Create JSON payload&#10;                val jsonPayload = org.json.JSONObject().apply {&#10;                    put(&quot;word&quot;, word)&#10;                    put(&quot;maskedIndex&quot;, maskedIndex)&#10;                    put(&quot;configurationType&quot;, configurationType)&#10;                }.toString()&#10;                &#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LEARN_MODE_WORD_DATA,&#10;                        jsonPayload.toByteArray()&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Word data sent to watch: $word (masked: $maskedIndex, type: $configurationType)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send word data to watch&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Send letter validation result back to watch for Write the Word mode&#10;     * @param isCorrect Whether the input letter was correct&#10;     * @param currentIndex Current letter index being spelled (next letter to input)&#10;     * @param totalLetters Total letters in the word&#10;     */&#10;    fun sendLetterResult(isCorrect: Boolean, currentIndex: Int, totalLetters: Int) {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                val payload = org.json.JSONObject().apply {&#10;                    put(&quot;isCorrect&quot;, isCorrect)&#10;                    put(&quot;currentIndex&quot;, currentIndex)&#10;                    put(&quot;totalLetters&quot;, totalLetters)&#10;                }.toString()&#10;&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_LETTER_RESULT,&#10;                        payload.toByteArray()&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Letter result sent: correct=$isCorrect, index=$currentIndex/$totalLetters&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send letter result&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Notify watch that word was completed successfully&#10;     */&#10;    fun sendWordComplete() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                nodes.forEach { node -&gt;&#10;                    messageClient.sendMessage(&#10;                        node.id,&#10;                        MESSAGE_PATH_WORD_COMPLETE,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;                Log.d(TAG, &quot;✅ Word complete notification sent&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send word complete&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Request device info from connected watch&#10;     */&#10;    fun requestDeviceInfo() {&#10;        scope.launch {&#10;            try {&#10;                val currentInfo = _deviceInfo.value&#10;                if (currentInfo.isConnected &amp;&amp; currentInfo.nodeId.isNotEmpty()) {&#10;                    messageClient.sendMessage(&#10;                        currentInfo.nodeId,&#10;                        MESSAGE_PATH_REQUEST_DEVICE_INFO,&#10;                        ByteArray(0)&#10;                    ).await()&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Request battery from currently connected watch&#10;     * Call this when UI needs fresh battery data (e.g., Dashboard onResume)&#10;     */&#10;    fun requestBatteryFromConnectedWatch() {&#10;        scope.launch {&#10;            try {&#10;                val currentDevice = _deviceInfo.value&#10;                &#10;                Log.d(TAG, &quot; Phone requesting battery - isConnected: ${currentDevice.isConnected}, state: ${currentDevice.connectionState}, nodeId: ${currentDevice.nodeId}&quot;)&#10;                &#10;                // Only request if watch is fully connected with app&#10;                if (currentDevice.isConnected &amp;&amp; &#10;                    currentDevice.connectionState == ConnectionState.WATCH_CONNECTED &amp;&amp;&#10;                    currentDevice.nodeId.isNotEmpty()) {&#10;                    &#10;                    // Send immediate battery request (with retry)&#10;                    repeat(3) { attempt -&gt;&#10;                        Log.d(TAG, &quot; Sending battery request (attempt ${attempt + 1}/3) to ${currentDevice.nodeId}&quot;)&#10;                        messageClient.sendMessage(&#10;                            currentDevice.nodeId,&#10;                            MESSAGE_PATH_REQUEST_BATTERY,&#10;                            ByteArray(0)&#10;                        ).await()&#10;                        Log.d(TAG, &quot;✅ Battery request sent successfully (attempt ${attempt + 1}/3)&quot;)&#10;                        &#10;                        if (attempt &lt; 2) {&#10;                            delay(1000L) // 1 second between retries&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.w(TAG, &quot;⚠️ Cannot request battery - watch not fully connected&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to send battery request&quot;, e)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Handle incoming messages from watch&#10;     */&#10;    private fun handleIncomingMessage(messageEvent: MessageEvent) {&#10;        Log.d(TAG, &quot; Processing message: ${messageEvent.path}&quot;)&#10;        when (messageEvent.path) {&#10;            MESSAGE_PATH_PING -&gt; {&#10;                // Watch is checking if Kusho app is running - respond with PONG&#10;                Log.d(TAG, &quot; Received PING from watch, sending PONG response&quot;)&#10;                scope.launch {&#10;                    try {&#10;                        messageClient.sendMessage(&#10;                            messageEvent.sourceNodeId,&#10;                            MESSAGE_PATH_PONG,&#10;                            &quot;pong&quot;.toByteArray()&#10;                        ).await()&#10;                        Log.d(TAG, &quot;✅ PONG sent successfully&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;❌ Failed to send PONG&quot;, e)&#10;                    }&#10;                }&#10;            }&#10;            MESSAGE_PATH_BATTERY_STATUS -&gt; {&#10;                val batteryLevel = String(messageEvent.data).toIntOrNull()&#10;                Log.d(TAG, &quot; Received battery status: ${batteryLevel?.let { &quot;$it%&quot; } ?: &quot;parsing failed&quot;}&quot;)&#10;                _deviceInfo.value = _deviceInfo.value.copy(&#10;                    batteryPercentage = batteryLevel,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;                Log.d(TAG, &quot;✅ Updated device info with battery: ${batteryLevel?.let { &quot;$it%&quot; } ?: &quot;null&quot;}&quot;)&#10;            }&#10;            MESSAGE_PATH_DEVICE_INFO -&gt; {&#10;                val deviceName = String(messageEvent.data)&#10;                Log.d(TAG, &quot; Received device info: $deviceName&quot;)&#10;                _deviceInfo.value = _deviceInfo.value.copy(&#10;                    name = deviceName,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;            }&#10;            MESSAGE_PATH_LEARN_MODE_SKIP -&gt; {&#10;                Log.d(TAG, &quot;⏭️ Received Learn Mode skip command from watch&quot;)&#10;                // Trigger skip by updating the timestamp&#10;                _learnModeSkipTrigger.value = System.currentTimeMillis()&#10;            }&#10;            MESSAGE_PATH_LETTER_INPUT -&gt; {&#10;                try {&#10;                    val jsonString = String(messageEvent.data)&#10;                    val json = org.json.JSONObject(jsonString)&#10;                    val letter = json.optString(&quot;letter&quot;, &quot;&quot;).firstOrNull() ?: return&#10;                    val letterIndex = json.optInt(&quot;letterIndex&quot;, 0)&#10;                    Log.d(TAG, &quot; Received letter input from watch: $letter at index $letterIndex&quot;)&#10;                    _letterInputEvent.value = LetterInputEvent(&#10;                        letter = letter, // Keep exact case - don't convert to uppercase&#10;                        letterIndex = letterIndex,&#10;                        timestamp = System.currentTimeMillis()&#10;                    )&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;❌ Failed to parse letter input&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Parse device name to get user-friendly name&#10;     */&#10;    private fun getDeviceName(displayName: String): String {&#10;        return when {&#10;            displayName.contains(&quot;Galaxy Watch&quot;, ignoreCase = true) -&gt; displayName&#10;            displayName.contains(&quot;Watch&quot;, ignoreCase = true) -&gt; displayName&#10;            else -&gt; &quot;Smartwatch&quot; // Default name for non-Galaxy watches&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get list of all connected nodes&#10;     */&#10;    suspend fun getConnectedNodes(): List&lt;Node&gt; {&#10;        return try {&#10;            nodeClient.connectedNodes.await()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            emptyList()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clear connection state (useful for testing or when user manually disconnects)&#10;     */&#10;    fun clearConnection() {&#10;        _deviceInfo.value = WatchDeviceInfo(&#10;            isConnected = false,&#10;            connectionState = ConnectionState.NO_WATCH&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Open Play Store on watch using RemoteActivityHelper&#10;     * This works even if the Kusho app is NOT installed on the watch yet.&#10;     */&#10;    fun openPlayStoreOnWatch() {&#10;        scope.launch {&#10;            try {&#10;                val nodes = nodeClient.connectedNodes.await()&#10;                &#10;                if (nodes.isEmpty()) {&#10;                    Log.w(TAG, &quot;⚠️ Cannot open Play Store - no connected watch nodes&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // RemoteActivityHelper needs a context and an executor&#10;                val remoteActivityHelper = RemoteActivityHelper(context, Executors.newSingleThreadExecutor())&#10;&#10;                // The Intent to open the Play Store specifically for YOUR app package&#10;                val intent = Intent(Intent.ACTION_VIEW)&#10;                    .addCategory(Intent.CATEGORY_BROWSABLE)&#10;                    .setData(Uri.parse(&quot;market://details?id=com.example.kusho&quot;))&#10;&#10;                for (node in nodes) {&#10;                    remoteActivityHelper.startRemoteActivity(&#10;                        intent,&#10;                        node.id&#10;                    )&#10;                    Log.d(TAG, &quot;✅ Sent Remote Intent to open Play Store on: ${node.displayName}&quot;)&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Failed to open Play Store on watch&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Create notification channel for install prompts&#10;     */&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                NOTIFICATION_CHANNEL_ID,&#10;                &quot;Watch App Installation&quot;,&#10;                NotificationManager.IMPORTANCE_HIGH&#10;            ).apply {&#10;                description = &quot;Notifications for installing the Kusho watch app&quot;&#10;                enableVibration(true)&#10;            }&#10;            &#10;            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clean up resources&#10;     * Note: Does NOT cancel scope since this is a singleton that persists across screens&#10;     */&#10;    fun cleanup() {&#10;        stopMonitoring()&#10;        messageClient.removeListener(messageListener)&#10;        capabilityClient.removeListener(capabilityListener)&#10;        try {&#10;            context.unregisterReceiver(bluetoothStateReceiver)&#10;        } catch (e: Exception) {&#10;            // Receiver might not be registered&#10;        }&#10;        // DO NOT cancel scope - singleton needs persistent scope&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/TutorialActivityCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/TutorialActivityCard.kt" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.tutorialmode&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.example.app.R&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.material3.MaterialTheme&#10;&#10;/**&#10; * Component for displaying a tutorial activity card with icon and title.&#10; * Uses yellow/orange color scheme with dashed border.&#10; *&#10; * @param title The activity title&#10; * @param iconRes The resource ID of the icon image&#10; * @param isSelected Whether the card is selected&#10; * @param onClick Callback when card is clicked&#10; * @param modifier Optional modifier for the card&#10; */&#10;@Composable&#10;fun TutorialActivityCard(&#10;    title: String,&#10;    iconRes: Int,&#10;    isSelected: Boolean = false,&#10;    onClick: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val yellowColor = Color(0xFFEDBB00)&#10;    val lightYellowColor = Color(0x80EDBB00)&#10;    val greenColor = Color(0xFF4CAF50)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(175.dp)&#10;            .clip(RoundedCornerShape(28.dp))&#10;            .background(if (isSelected) yellowColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .then(&#10;                if (!isSelected) {&#10;                    Modifier.drawBehind {&#10;                        val pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 20f), 0f)&#10;                        drawRoundRect(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 12f, pathEffect = pathEffect),&#10;                            cornerRadius = CornerRadius(28.dp.toPx())&#10;                        )&#10;                    }&#10;                } else {&#10;                    Modifier&#10;                }&#10;            )&#10;            .padding(12.dp)&#10;    ) {&#10;        // Selection circle at top right&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .size(36.dp)&#10;                .clip(CircleShape)&#10;                .background(if (isSelected) Color.White else Color.Transparent)&#10;                .drawBehind {&#10;                    if (!isSelected) {&#10;                        drawCircle(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 4f)&#10;                        )&#10;                    }&#10;                },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = greenColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Icon Circle with Border&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Transparent)&#10;                    .drawBehind {&#10;                        drawCircle(&#10;                            color = if (isSelected) Color(0x40FFFFFF) else lightYellowColor,&#10;                            style = Stroke(width = 16f)&#10;                        )&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(CircleShape)&#10;                        .background(if (isSelected) Color.White else yellowColor),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = title,&#10;                        modifier = Modifier.size(60.dp),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Title&#10;            Text(&#10;                text = title,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Normal,&#10;                color = if (isSelected) Color.White else yellowColor,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Unselected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = false,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Selected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardSelectedPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = true,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/components/tutorial/TutorialActivityCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/app/ui/feature/learn/tutorialmode/components/tutorial/TutorialActivityCard.kt" />
              <option name="updatedContent" value="package com.example.app.ui.feature.learn.tutorialmode.components.tutorial&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawBehind&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.PathEffect&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.example.app.R&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.material3.MaterialTheme&#10;&#10;/**&#10; * Component for displaying a tutorial activity card with icon and title.&#10; * Uses yellow/orange color scheme with dashed border.&#10; *&#10; * @param title The activity title&#10; * @param iconRes The resource ID of the icon image&#10; * @param isSelected Whether the card is selected&#10; * @param onClick Callback when card is clicked&#10; * @param modifier Optional modifier for the card&#10; */&#10;@Composable&#10;fun TutorialActivityCard(&#10;    title: String,&#10;    iconRes: Int,&#10;    isSelected: Boolean = false,&#10;    onClick: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val yellowColor = Color(0xFFEDBB00)&#10;    val lightYellowColor = Color(0x80EDBB00)&#10;    val greenColor = Color(0xFF4CAF50)&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(175.dp)&#10;            .clip(RoundedCornerShape(28.dp))&#10;            .background(if (isSelected) yellowColor else Color.Transparent)&#10;            .clickable { onClick() }&#10;            .then(&#10;                if (!isSelected) {&#10;                    Modifier.drawBehind {&#10;                        val pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 20f), 0f)&#10;                        drawRoundRect(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 12f, pathEffect = pathEffect),&#10;                            cornerRadius = CornerRadius(28.dp.toPx())&#10;                        )&#10;                    }&#10;                } else {&#10;                    Modifier&#10;                }&#10;            )&#10;            .padding(12.dp)&#10;    ) {&#10;        // Selection circle at top right&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .size(36.dp)&#10;                .clip(CircleShape)&#10;                .background(if (isSelected) Color.White else Color.Transparent)&#10;                .drawBehind {&#10;                    if (!isSelected) {&#10;                        drawCircle(&#10;                            color = yellowColor,&#10;                            style = Stroke(width = 4f)&#10;                        )&#10;                    }&#10;                },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = greenColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Icon Circle with Border&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color.Transparent)&#10;                    .drawBehind {&#10;                        drawCircle(&#10;                            color = if (isSelected) Color(0x40FFFFFF) else lightYellowColor,&#10;                            style = Stroke(width = 16f)&#10;                        )&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(CircleShape)&#10;                        .background(if (isSelected) Color.White else yellowColor),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = title,&#10;                        modifier = Modifier.size(60.dp),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Title&#10;            Text(&#10;                text = title,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Normal,&#10;                color = if (isSelected) Color.White else yellowColor,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Unselected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = false,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(&#10;    name = &quot;TutorialActivityCard Selected&quot;,&#10;    showBackground = true,&#10;    backgroundColor = 0xFFFFFFFF&#10;)&#10;@Composable&#10;fun TutorialActivityCardSelectedPreview() {&#10;    MaterialTheme {&#10;        TutorialActivityCard(&#10;            title = &quot;Vowels&quot;,&#10;            iconRes = R.drawable.ic_apple,&#10;            isSelected = true,&#10;            onClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_watch_temp.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;960&quot;&#10;    android:viewportHeight=&quot;960&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#000000&quot;&#10;        android:pathData=&quot;M420,160h120,-120ZM420,800h120,-120ZM360,880l-54,-182q-48,-38 -77,-95t-29,-123q0,-66 29,-123t77,-95l54,-182h240l54,182q48,38 77,95t29,123q0,66 -29,123t-77,95L600,880L360,880ZM480,680q83,0 141.5,-58.5T680,480q0,-83 -58.5,-141.5T480,320q-83,0 -141.5,58.5T280,480q0,83 58.5,141.5T480,680ZM404,210q20,-5 38.5,-8t37.5,-3q19,0 37.5,3t38.5,8l-16,-50L420,160l-16,50ZM420,800h120l16,-50q-20,5 -38.5,7.5T480,760q-19,0 -37.5,-2.5T404,750l16,50Z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>